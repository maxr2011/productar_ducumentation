\documentclass{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{xcolor}

\usepackage{graphics}           % Add pictures to the document
\usepackage{graphicx}           % Add pictures to the document
\usepackage{subfigure}          % 2 pictures side by side

\PassOptionsToPackage{hyphens}{url}
\usepackage[breaklinks=true]{hyperref}   % Add a link to the document
\usepackage[hyphens]{url}

\title{Dokumentation ProductAR}
\author{Maximilian Rehberger}
\date{\today}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\definecolor{darkcerulean}{rgb}{0.03, 0.27, 0.49}
\definecolor{frenchblue}{rgb}{0.0, 0.45, 0.73}
\definecolor{babyblueeyes}{rgb}{0.63, 0.79, 0.95}

\addtokomafont{section}{\color{darkcerulean}}
\addtokomafont{subsection}{\color{frenchblue}}
\addtokomafont{subsubsection}{\color{babyblueeyes}}

\graphicspath{ {./img/} }                % Path to images

\begin{document}

\maketitle

\begin{figure}[h]
\centering
\includegraphics[width=150px]{img/app_icon.png}
\end{figure}



\newpage


\renewcommand*\contentsname{}
\section{Inhaltsverzeichnis}
\tableofcontents{}


\newpage

\section{Einleitung}

\subsection{Zweck}

Produkte können zum Beispiel beim Einkaufen mit dem Smartphone gescannt werden und erkannt werden. Informationen werden angezeigt wie zum Beispiel Bilder oder ein Preisvergleich. Mithilfe der App soll man einen Barcode einscannen können und Informationen zu den Produkten erhalten. Weiterhin kann der Nutzer ein Produkt in Augmented Reality (AR) testen und sieht somit wie es in Wirklichkeit aussehen wird, wenn er es kaufen würden.

\newpage

\section{Allgemeine Übersicht}

\subsection{Beschreibung Ausgangssituation}

Es gibt bereits viele Shopping-Apps wie zum Beispiel Ikea, H\&M oder S'Oliver. Das Problem ist, dass jeder am Ende für jedes Geschäft eine eigene App auf dem Smartphone hat. Diese App soll die Möglichkeiten geben mehrere unterschiedliche Produkte in einer App zu speichern und zu verwalten. Also eine App für alle Produkte.

\subsection{Produkteinsatz}

 Die App kann zum Beispiel als Einkaufsliste oder Wunschliste für Produkte eingesetzt werden.
 Darüber hinaus bieten sich noch viele weitere Möglichkeiten.

\subsection{Produktumfeld}

Die App wird hauptsächlich im privaten Umfeld umgesetzt, beim Einkaufen in Geschäften oder Online-Einkauf.

\subsection{Produktfunktionalität}

Scannen von Produkten, Informationen zu Produkten, Preisvergleich, Bilder hochladen für Produkte, Produkte in AR testen.

\subsection{Personas}

\subsubsection{Nutzer}

Die Hauptzielgruppe, für welche die App interessant ist, sind "Käufer" und "Verkäufer". Deshalb sind diese für Nutzer noch einmal in einer Unterkategorie zusammengefasst.

\paragraph{Käufer} \mbox{}\newline

\noindent \textbf{Nutzer 1: \newline}
\textbf{Name:} Jonas \newline
\textbf{Alter:} 21 Jahre \newline 
\textbf{Status:} ledig \newline 
\textbf{Eigenschaften:} zurückhaltender \& stiller Typ \newline
\textbf{Beschäftigung:} E-Commerce Student \newline
\textbf{Hobbys:} Zocken, Serien schauen \newline

\noindent Jonas beginnt gerade sein E-Commerce Studium in Würzburg. Mit viel Glück hat er eine Wohnung in der Stadt gefunden. Er befindet sich gerade im Umzug. Das Geld, welches er sich in den Ferien erarbeitet hat, nimmt er um die Möbel für seine neue Wohnung einzukaufen. Um nicht ständig alle Produkte aufschreiben zu müssen, möchte er eine App benutzen, mit der sich Produkte einfach abspeichern lassen. Außerdem möchte er Fotos von den Möbeln machen um sie seinen Eltern zeigen zu können. Er fände es cool, wenn er die Möbel schon gleich bei sich in der Wohnung mit Augmented Reality (AR) ausprobieren kann. \newline 

\noindent \textbf{Nutzer 2: \newline}
\textbf{Name:} Larissa \newline
\textbf{Alter:} 24 Jahre \newline 
\textbf{Status:} In einer Beziehung \newline 
\textbf{Eigenschaften:} extrovertiert \& unternehmenslustig \newline
\textbf{Beschäftigung:} BWL Studentin \newline
\textbf{Hobbys:} Shopping, Fotografie, Mit Freunden treffen \newline

\noindent Larissa muss immer das neuste haben. Egal ob Kleidung, Schmuck oder Elektronik. Sie möchte ungern das Produkt von gestern besitzen, sondern immer das neueste, damit Sie es gleich ihren Freunden zeigen kann. Sie findet eine App sehr praktisch mit der sie Produkte abspeichern kann um sie hinterher wieder zu finden. Außerdem schaut sie sich gerne Fotos von anderen Nutzern zu bestimmten Produkten an, sowie deren Bewertungen um hinterher zu wissen, wie diese die Produkte finden. \newline 

\noindent \textbf{Nutzer 3: \newline}
\textbf{Name:} Thorsten \newline
\textbf{Alter:} 35 Jahre \newline 
\textbf{Status:} ledig \newline 
\textbf{Eigenschaften:} vielbeschäftigt, hat kaum Zeit \newline
\textbf{Beschäftigung:} Geschäftsmann \newline
\textbf{Hobbys:} Keine \newline

\noindent Thorsten hat gar keine Zeit um sich stundenlang im Internet das beste Angebot für zum Beispiel ein neues Handy herauszusuchen. Er ist vielbeschäftigt und möchte daher eine App benutzen, welche ihm anzeigt, bei welchem Geschäft das Produkt gerade am günstigsten ist. Wenn ein Produkt stark reduziert ist beziehungsweise im Angebot ist möchte er automatisch eine Benachrichtung erhalten.

\paragraph{Verkäufer} \mbox{} \newline

\noindent \textbf{Nutzer 4: \newline}
\textbf{Name:} Lukas \newline
\textbf{Alter:} 32 Jahre \newline 
\textbf{Status:} ledig \newline 
\textbf{Eigenschaften:} handwerklich begabt \newline
\textbf{Beschäftigung:} Besitzer eines Möbelgeschäftes in Würzburg \newline
\textbf{Hobbys:} Möbel entwerfen und zusammen bauen, Grillen mit Freunden \newline

\noindent In den letzten Jahren läuft das Geschäft, welches Lukas betreibt immer schlechter. Die Leute bestellen meistens im Internet, oder kaufen beim Konkurrenten IKEA ein.
Dabei sind seine Möbel selbst nach bester Handwerkskunst gefertigt und kosten auch nicht viel mehr im Vergleich zu Markenmöbeln. Lukas muss sich etwas inovatives einfallen lassen. Er würde gerne seine Möbel online anbieten, damit mehr Leute bei Ihm einkaufen. Mithilfe der App kann er seine Möbel mit Bildern integrieren, damit die Leute sie in der App finden können.
Er hat die Möglichkeit ein individuelles 3D Model für seine Möbel zu erstellen, damit man diese in der App in Augemented Reality (AR) testen kann. \newline 

\subsubsection{Content-Manager}

Als Content-Manager möchte ich Updates (und Change-logs) erstellen können um die App immer auf den aktuellsten Stand zu halten, um zum Beispiel neue Produkte oder neue 3D Modelle hinzufügen zu können.
Auch soll man in der Lage sein, die Sperrwörter liste aktualisieren zu können, um zu verhindern das illegale Produkte erstellt werden können. \newline 

\subsubsection{Admin}

Als Admin möchte ich Analysen erstellen können, damit ich zum Beispiel ermitteln kann, wie viele Nutzer die App benutzt haben um ein Produkt für IKEA hinzuzufügen.
Außerdem möchte ich auf die Datenbank zugreifen können, damit ich neue Tabellen Einträge erstellen kann oder um Fehler beheben zu können. \newline 

\subsection{Anforderungsanalyse}

\noindent Die App muss die Produkte anhand \newline 

\noindent - Eines Barcodes (Kamera) erkennen und mithilfe einer Tabelle zuordnen können \newline 
\noindent - Ihrer Form entsprechend erkennen und zuordnen können (konzeptionell). Diese Funktion wurde nicht in der fertigen App umgesetzt. \newline 

\noindent Unterscheiden können zwischen den Produkten \newline
\noindent - zum Beispiel zwischen einer Banane und einem Apfel \newline 
\noindent - Einfache Klassifizierer oder KI \newline

\noindent Möglichkeit zum Testen von Produkten innerhalb der App  \newline 
\noindent - Hierbei wird ein AR-Objekt erzeugt \newline

\subsubsection{Anforderungen der Personas}

Die Anforderungsanalyse wird nun ergänzt mit den Anforderungen, welche die Personas sich von der App vorgestellt haben. \newline 

\noindent - Möglichkeit zum Speichern von Produkten in der App \newline 
\noindent - Fotos von Produkten erstellen \newline 
\noindent - Fotos von anderen zu einem Produkt sehen können \newline 
\noindent - Produkt bewerten und Bewertungen einsehen können \newline 
\noindent - Produkte in Augmented Reality (AR) testen \newline 
\noindent - Preisvergleich (bei welchem Geschäft zurzeit am günstigsten)\newline 
\noindent - Benachrichtigungen, wenn Produkte im Angebot sind \newline
\noindent - Die Möglichkeit für Verkäufer Produkte einzustellen \newline 
\noindent - Die Möglichkeit für Verkäufer eigene 3D Modelle hochzuladen \newline

\newpage

\section{Architekturkonzept und Entwurf}

\subsection{Ursprüngliches Architekturkonzept}

\begin{figure}[h]
\centering
\includegraphics[width=380px]{img/Architekturkonzept.png}
\caption{Ursprüngliches Architekturkonzept}
\end{figure}

\subsection{Aktualisiertes Architekturkonzept}

\begin{figure}[h]
\centering
\includegraphics[width=380px]{img/ArchitekturkonzeptNew.png}
\caption{Aktualisiertes Architekturkonzept}
\end{figure}

\newpage

\subsection{Anfängliche Skizze Datenbankentwurf}

\subsubsection{MySQL Datenkbank (Remote)}

Ursprünglich war geplant, dass die Daten ausschließlich auf dem Server in einer MySQL Datenbank gespeichert werden.

\begin{figure}[h]
\centering
\includegraphics[width=380px]{img/Skizze_Datenbank_1.png}
\caption{Anfängliche Skizze Datenbankentwurf}
\end{figure}

\newpage

\subsection{Anfängliche Skizze Java Klassen}

Es handelt sich hierbei lediglich um die Objekt Klassen.

\begin{figure}[h]
\centering
\includegraphics[width=320px]{img/Skizze_Java_1.png}
\caption{Anfängliche Skizze Datenbankentwurf}
\end{figure}

\newpage

\subsection{Endgültige Skizze Datenbankentwurf}

\subsubsection{SQLite Datenbank (Lokal)}

\begin{figure}[h]
\centering
\includegraphics[width=180px]{img/Skizze_Datenbank_SQLite.png}
\caption{Skizze Datenbankentwurf: SQLite}
\end{figure}

\subsubsection{MySQL Datenbank (Remote)}

\begin{figure}[h]
\centering
\includegraphics[width=380px]{img/Skizze_Datenbank_2.png}
\caption{Aktualisierte Skizze Datenbankentwurf: MySQL}
\end{figure}

\newpage

\subsection{Endgültige Skizze Java Klassen}

\begin{figure}[h]
\centering
\includegraphics[width=380px]{img/Skizze_Java_New.png}
\caption{Aktualisierte Skizze: Java Klassen}
\end{figure}

\subsection{Übersicht Backend Server}

Der Backend Server ist ein gemieteter Server von Hosteurope. \newline
Produktbezeichnung: "Virtual Server Linux Advanced 8.2". \newline
Dieser hat folgende Linux Version installiert: Ubuntu 16.04.6 LTS. \newline \newline

\noindent Die Technischen Spezifikationen lauten wie folgt: \newline 

\noindent 4 virtuelle Kerne \newline
\noindent 6 GB RAM \newline 
\noindent 200GB SSD \newline 

\noindent Es handelt sich hierbei um einen virtuellen Server, das bedeutet, dass sich der Server mit anderen "Containern" die Hardware eines realen Servers teilen. % Die Hardware eines großen Server wird auf die Container entsprechend aufgeteilt. % 
\newline

\noindent Der Server hat eine eigene Domain: www.nimoo.de. 

\newpage

\subsection{Übersicht REST API}

Die Rest Schnittstelle wurde mit PHP auf dem Webserver umgesetzt welcher vom Backend Server bereits zur Verfügung gestellt wurde. 
Für jede Ressource existiert ein Pfad, mit entsprechender PHP Datei. \newline 

\noindent Der Hauptpfad für die App auf dem Webserver: "https://www.nimoo.de/apps/productar" \newline

\noindent Folgende Pfade existieren auf dem Webserver: \newline

\noindent ../products/ \newline
\noindent ../products/images/ \newline
\noindent ../products/photos/ \newline
\noindent ../products/prices/ \newline
\noindent ../products/ratings/ \newline
\noindent ../users/ \newline
\noindent ../users/images \newline
\noindent ../models/ \newline

\subsection{Technische Entscheidungen}

\subsubsection{Warum Android?}

Die Entscheidung, die App für Android zu entwickeln wurde getroffen, da Android zumindest in Deutschland einen höheren Marktanteil besitzt als iOS. Vor allem die Studenten der Fakultät Informatik und Wirtschaftsinformatik (FIW) und in der Vertiefung Mobile Solutions benutzen mehrheitlich Android Smartphones. Ein weiterer Grund ist, dass Android Java basiert ist und dafür sehr gut geeignet ist, wenn bereits fortgeschrittene Erfahrungen mit der Programmiersprache Java gegeben sind. Weiterhin gibt es beim Entwickeln keine Mehrkosten, da es bereits viele Open-Source Erweiterungen (Bibliotheken) gibt und Anleitungen, die das Entwickeln weiter vereinfachen.

\subsubsection{Welche Androidversion?}

Als minimal unterstützte Android Version (minSdkVersion) für die App musste die Api 24 (Android 7) verwendet werden. Dies liegt daran, dass die AR Funktionialität mit der Google AR Core Erweiterung erst ab Android Version 7 (Api 24) unterstützt wurde und alle vorherigen Versionen keine Unterstützung haben. Dies hat den Nachteil, dass nur ca. 37,1 \% aller Android Geräte unterstützt werden im Vergleich zu den 95,3 \% die mit Android 4.4 (Api 19) unterstützt würden. 

\subsubsection{Welche Entwicklungsumgebung?}

Zum Entwickeln der App wurde hauptsächlich die Entwicklungsumgebung von Android Studio und IntelliJ genutzt.

\subsubsection{Wieso Google AR Core?}

Googles neuestes Framework für Augmented Reality Anwendungen heist "AR Core". Im Vergleich zu einer AR Anwendung mit Unity lässt es es sich sehr einfach in die App integrieren (Als Fragment oder View in der Aktivity). Weiterhin lassen sich Modelle (.OBJ) sehr einfach mit dem Sceneform Plugin einbinden und bearbeiten. 

\subsubsection{Wieso einen Barcode-Scanner?}

Für Produkte, welche in einem lokalen Geschäft angeboten werden, wird meistens ein numerischer Barcode verwendet, da dieser leicht an der Kasse über das Band gezogen und gescannt werden kann um so erfasst zu werden.

\subsubsection{Wieso kein Scanner, welcher das Produkt anhand der Form erkennt?}

Es ist sehr aufwendig eine KI zu entwickeln, oder anzulernen, welche Produkte anhand Ihrer Form erkennen kann. Selbst dann ist diese sehr fehleranfällig und unausgereift. Der Barcode Scanner ist in diesem Fall wesentlich zuverlässiger darin Produkte zu erkennen wie der KI-Scanner. Daher wird das Konzept in der Implementation der App nicht weiter verfolgt.

\subsubsection{Wieso eine MySQL Datenbank?}

Zum einen war die MySQL Datenbank ebenfalls schon auf dem Backend Server aufgesetzt, somit war keine weitere Konfiguration notwendig. Weiterhin ist es sehr einfach eine Datenbank mit SQL zu erstellen und Abfragen durchzuführen.

\subsubsection{Wieso eine REST API?}

Die Rest API ist die Schnittstelle zwischen der App und der Datenbank auf dem Server. Diese wird benötigt, da man aus Sicherheitsgründen keine direkte Verbindung zwischen App und Datenbank zulassen darf.

\subsubsection{Vergleich mit Alternativlösungen}

\paragraph{Firebase von Google}.\newline

\noindent Die Backendlösung von Google ist "FireBase" und wäre erheblich einfacher umzusetzten und hätte ebenfalls den Vorteil, dass kein externer Server benötigt wird. Warum wurde diese Lösung in diesem Projekt jedoch nicht verwendet? Die Datenbank enthält sensible Daten, wie zum Beispiel Nutzerdaten. Diese sollen nicht an Google gesendet werden.

\paragraph{Alternative Datenbankmodelle}.\newline

\noindent PostgreSQL und MongoDB. MongoDB ist dokumentenorientiert und speichert Datensätze im JSON Format ab. PostgreSQL ist MySQL sehr ähnlich.

\newpage

\section{Technische Dokumentation}

Die Dokumentation der einzelnen Java Klassen befindet sich im generierten JavaDoc Verzeichnis. Die nachfolgende Dokumentation wurde aus den JavaDoc Kommentaren übernommen. Bestimmte Klassen können doppelt vorkommen.

\subsection{Android Manifest}

\subsection{Java Interfaces}

\subsubsection{ObjectInterface}

Das Interface "ObjectInterface" definiert die Vorgaben, welches ein Objekt erfüllen muss. Ein Objekt benötigt eine id als eindeutigen Identifizierer und einen Namen. Entsprechende Getter und Setter sind hier definiert.

\subsubsection{ScanResultReceiver}

Das Interface "ScanResultReceiver" definiert die Methoden, welche nach dem Scannen eines Barcodes ausgeführt werden. \newline

\noindent\textbf{Methode scanResultData(NoScanResultException noScanData)}\newline Die Methode "scanResultData" wird aufgerufen, wenn das Scannen des Barcodes fehlgeschlagen ist.\newline

\noindent\textbf{Methode scanResultData(java.lang.String codeFormat, java.lang.String codeContent)}\newline Die Methode "scanResultData" wird nach dem erfolgreichen Scannen des Barcodes aufgerufen.

\subsubsection{IRetrofitCRUD}

Das Interface "IRetrofitCRUD" definiert die Methoden, welche aufgerufen werden um über Retrofit Anfragen an den Server zu stellen.

\subsubsection{JsonPlaceHolderApi}

Das Interface "JsonPlaceHolderApi" ist die direkte Schnittstelle zwischen Retrofit und dem Zielserver. Verwendete HTTP Verbs: GET und POST.

\subsection{Java Klassen}

\subsubsection{Objekt Klassen}

\paragraph{Object Class (Abstract)}

Die Klasse "ObjectClass" ist eine abstrakte Klasse, welche die benötigten Methoden für ein Objekt implementiert.

\paragraph{Product}

Die Klasse "Product" stellt die Objektklasse für ein Produkt dar. Ein Produkt ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{User}

Die Klasse "User" stellt die Objektklasse für einen Benutzer dar. Ein Benutzer ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{Model}

Die Klasse "Model" stellt die Objektklasse für ein (AR) Model dar. Ein Model ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{Photo}

Die Klasse "Photo" stellt die Objektklasse für ein Foto dar. Ein Foto ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{Price}

Die Klasse "Price" stellt die Objektklasse für einen Preis dar. Ein Preis ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{Shop}

Die Klasse "Shop" stellt die Objektklasse für einen Shop dar. Ein Shop ist gleichzeitig ein Objekt. Hier werden wichtige Methoden und Konstruktoren implementiert. Die Werte können über Getter und Setter Methoden abgefragt werden.

\paragraph{Category (Enum)}

Die Enumklasse "Category" beinhaltet die Produktkategorien. Es gibt folgende Kategorien: Accessoires, Auto, Baumarkt, Beauty, Bücher, Computer, Drogerie, Elektronik, Filme, Garten, Haushalt, Kleidung, Lebensmittel, Möbel, Musik, Schuhe, Serien, Spiele, Spielzeug, Sport.

\paragraph{Currency (Enum)}

Die Enumklasse "Currency" beinhaltet die aktuell unterstützten Währungen. In diesem Fall: Dollar und Euro.

\paragraph{Interval (Enum)}

Die Enumklasse "Interval" beinhaltet die Möglichkeiten für ein Updateinterval der Benachrichtigungen. Folgende Intervalle sind für Benachrichtigungen möglich: Täglich, Wöchentlich, Monatlich.

\newpage

\subsubsection{Aktivity Klassen}

\paragraph{MainActivity}

\noindent Die Klasse "MainActivity" wird beim Starten der App ausgeführt, direkt nach dem "SplashScreen". Es können Barcodes gescannt und danach das Ergebnis angezeigt werden.\newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Hier werden Werte initialisiert, zum Beispiel TextViews oder Buttons. Es wird eine Datenbankverbindung zur lokalen SQLite Datenbank initialisiert. Ein OnClickListener wird für den Button "btn\_scan\_now" initialisiert. Für Android Versionen größer 23 (ab 24) wird ein NetworkMonitor Receiver erzeugt.\newline

\noindent\textbf{Methode onCreateOptionsMenu(android.view.Menu menu)}

\noindent Die Methode "onCreateOptionsMenu" erzeugt das Menü für die AktionsLeiste Es wird zuerst überprüft ob der Nutzer eingeloggt ist. Nutzername und Password werden in einem User Objekt gespeichert. Das Menü "menu\_loggedin" wird hier verwendet. Der Nutzername wird in das Feld "action\_username" eingetragen und ein OnClickListener erstellt mit der Methode "goToProfile". Für den Logout Button wird ebenfalls ein OnClickListener erstellt, welcher den Nutzer ausloggt. Ist der Nutzer allgemein nicht eingloggt, so wird stattdessen das Standardmenü geladen. \newline

\noindent\textbf{Methode onDestroy()}

\noindent Die Methode "onDestroy" wird beim verlassen der Activity ausgeführt. \newline

\noindent\textbf{Methode onOptionsItemSelected(android.view.MenuItem item)}

\noindent Die Methode "onOptionsItemsSelected" wird ausgeführt, wenn ein Menüelement ausgewählt wurde. Je nachdem um welches Element es sich handelt werden unterschiedliche Aktionen ausgeführt. Bei "action\_search": Man wird zur Suche weitergeleitet. Bei "action\_login": Wenn eingeloggt, dann wird man zum Profil weitergeleitet. Wenn nicht eingeloggt, dann wird man zum Login weitergeleitet. Bei "action\_settings": Man wird zu den Einstellungen weitergeleitet. Bei "action\_info": Man wird zu den Informationen über die App weitergeleitet. Bei "action\_close": Die App wird beendet. \newline

\noindent\textbf{Methode scanNow(android.view.View view)}

\noindent Die Methode "scanNow" wird ausgeführt, wenn der Button "btn\_scan\_now" geklickt wurde. Es wird ein ScanFragment erzeugt, welches als nächstes geöffnet wird. Die Kamera wird aktiviert und der Barcode Scanner wird initialisiert. \newline

\noindent\textbf{Methode scanResultData(java.lang.String codeFormat, java.lang.String codeResult)}

\noindent Die Methode "scanResultData" wird ausgeführt, wenn der Barcode Scanner einen Code erfolgreich gescannt hat. Zuerst wird geprüft ob der barcode existiert (!nullCheck) Als nächstes beginnt die Ladeanimation (loadingStart()) Es wird versucht den Barcode in eine Long Variable umzuwandeln um zu prüfen ob der Barcode numerisch ist. Wenn keine NumberFormatException abgefangen worden ist wird in der lokalen SQLite Datenbank nach einem Barcode gesucht, welcher schon existiert. Von diesem wird der Name und das Bild benötigt. Wenn kein Barcode lokal existiert, dann wird eine Abfrage mit Retrofit ausgeführt, welche prüft ob ein Produkt mit dem Barcode in der MySQL Datenbank auf dem Server vorhanden ist. Sollte ein Produkt auf dem Server existieren, dann wird es in die Lokale Datenbank übertragen Es wird zusätzlich überprüft ob ein Model zu dem Produkt in der lokalen Datenbank existiert, wenn nicht, dann wird eins vom Server angefragt und in die Datenbank übertragen. Wenn kein Produkt auf dem Server existiert, dann wird die Methode "createNewBarcode" aufgerufen um einen neues Produkt auf dem lokalen Gerät zu erstellen. Wenn der Barcode bereits lokal existiert, wird der Zeitstempel für das Produkt aktualisiert und die Anzahl der Scans um 1 inkrementiert. Außerdem wird das Produkt als "bereit zum Synchronisieren" gekennzeichnet Das Ergebnis für das Bild und den Namen aus der lokalen Datenbank wird nun angezeigt und in die davor vorgesehenen Views geladen. Abschließend wird die Ladeanimation wieder beendet (loadingEnd()) \newline

\noindent\textbf{Methode scanResultData(NoScanResultException noScanData)}

\noindent Für den Fall das der Scan fehlgeschlagen ist. \newline

\noindent\textbf{Methode createNewBarcode(java.lang.String newBarcode)}

\noindent Die Methode "createNewBarcode" leitet auf die "CreateProductActivity" weiter und übergibt dieser den gescannten Barcode. \newline

\noindent\textbf{Methode goToProfile()}

\noindent Die Methode "goToProfile" leitet einen zum Nutzerprofil weiter. \newline

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\newpage

\paragraph{SplashScreen}

Die "SplashScreen" Activity wird ganz am Anfang gestartet. Es wird ein Drawable angezeigt. Anschließend wird auf die "MainActivity" weitergeleitet. \newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" initialisiert Variablen und ruft die Methode "scheduleJob" auf. Weiterhin wird ein CountdownTimer eingestellt, welcher beim Ablauf auf die "MainActivity" weiterleitet. \newline

\noindent\textbf{Methode scheduleJob()}

\noindent Die Methode "scheduleJob" plant einen Job, welcher im Hintergrund ausgeführt werden soll. Dieser ist notwendig um den Nutzer in einem bestimmten Zeitinterval über Neuigkeiten oder Aktualisierungen informieren zu können. In diesem Fall wird der Nutzer über neue Angebote zu seinen Produkten informiert. \newline

\noindent\textbf{Methode cancelJob()}

\noindent Die Methode "cancelJob" entfernt den geplanten Job wieder. \newline

\newpage

\paragraph{ProductArActivity} Die Klasse "ProductArActivity" wird ausgeführt, wenn der Nutzer ein Produkt in AR testen möchte. Das Produkt kann auf eine beliebige gefundene Fläche in AR platziert werden. Wenn kein Produkt zum Testen ausgewählt wurde, dann erscheint ein leerer Einkaufswagen als Model zum Testen. \newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)} 

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Wenn ein Barcode von einem Produkt an die Activity übergeben wurde, dann wird das Model aus der lokalen SQLite Datenbank abgefragt, ansonsten wird ein Standardmodel verwendet. Wenn die Einstellung "AR Marker" nicht aktiv ist, dann geht es weiter. Das ArFragment wird initialisiert und es wird ein OnTapArPlaneListener erstellt, welcher ausgeführt wird, wenn man auf eine gefundene AR Fläche tippt. An dieser Stelle wird dann ein Ankerpunkt erzeugt, auf welchen das Model platziert wird.\newline

\noindent\textbf{Methode addModelToScene(com.google.ar.core.Anchor anchor, \newline com.google.ar.sceneform.rendering.ModelRenderable modelRenderable)} 

\noindent Die Methode "addModelToScene" fügt der Scene das Model hinzu. \newline 



\paragraph{ProductScanActivity} Die Klasse "ProductScanActivity" wird ausgeführt, wenn der Nutzer ein Produkt in AR testen möchte. Anders als bei der "ProductArActivity" wird das Produkt nur auf einen vorher generierten QR Code platziert, welcher dem Namen oder den Barcode des Produkts entspricht. Dies geschieht automatisch. Wenn kein Produkt zum Testen ausgewählt wurde, dann erscheint ein leerer Einkaufswagen als Model zum Testen. \newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Wenn ein Barcode von einem Produkt an die Activity übergeben wurde, dann wird das Model aus der lokalen SQLite Datenbank abgefragt, ansonsten wird ein Standardmodel verwendet. Wenn die Einstellung "AR Marker" aktiv ist, dann geht es weiter. In diesem Fall wird ein CustomArFragment initialisiert und ein OnUpdateListener hinzugefügt. \newline

\noindent\textbf{Methode onUpdate(com.google.ar.sceneform.FrameTime frameTime)}

\noindent Die Methode "onUpdate" wird aufgerufen, wenn eine Aktualisierung in der AR Scene stattgefunden hat. Für jedes Image Target wird überprüft, ob es in der Scene getrackt wird. Wird ein Image Target getrackt, dann wird überprüft ob der key name des getrackten Images mit denen der festgelegten Image Targets übereinstimmt. Wenn es übereinstimmt, dann wird eine Toast Nachricht angezeigt. Anschließend wird ein Ankerpunkt in der Mitte des Image Targets platziert und die Methode "createModel" aufgerufen und dieser den Ankerpunkt übergeben. \newline

\noindent\textbf{Methode setupDatabase(com.google.ar.core.Config config, \newline com.google.ar.core.Session session)}

\noindent Die Methode "setupDatabase" erzeugt die AugmentedImageDatabase, in welcher die Bilder sind, welche in der AR Scene getrackt werden müssen. Es werden 3 Image Targets hinzugefügt. 1. Image Target: QR Code: "fox" 2. Image Target: QR Code: Name vom Produkt 3. Image Target: QR Code: Barcode vom Produkt. \newline

\noindent\textbf{Methode createModel(com.google.ar.core.Anchor anchor)}

\noindent Die Methode "createModel" erzeugt das Model auf den Ankerpunkt. \newline

\noindent\textbf{Methode 	placeModel(com.google.ar.sceneform.rendering.ModelRenderable \newline modelRenderable, com.google.ar.core.Anchor anchor)}

\noindent Die Methode "placeModel" platziert das Model. \newline



\paragraph{CaptureActivityPortrait}

Die Klasse "CaptureActivityPortrait" ist dafür da, dass der Barcode Scanner im Hochkant Format ausgeführt wird und nicht beim Drehen des Devices mitrotiert. \newline 


\paragraph{LastScannedProductsActivity}

Die Klasse "LastScannedProductsActivity" zeigt die zuletzt gescannten Produkte der Reihenfolge absteigend an. Es existiert eine "ListView" in der die Objekte geladen werden. \newline

\noindent\textbf{Methode onCreate(@Nullable android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Hier werden wichtige Werte initialisiert zum Beispiel eine ListView. Es wird eine Datenbankabfrage auf die Lokale SQLite Datenbank erzeugt, welche alle lokal gespeicherten Produkte nach Zeitstempel sortiert (neuesten zuerst) wieder zurück gibt. Wenn es keine Produkte gibt, so wird eine TextView "noContentText" sichtbar gemacht. Ansonsten werden die gefundenen Produkte nach und nach erzeugt und einer Liste hinzugefügt. Es wird ein ProductListAdapter mit dieser Liste erzeugt, welcher für die ListView gesetzt wird. Außerdem wird ein OnItemClickListener für jedes Item der ListView erzeugt, welcher auf die "ProductDetailActivity" für das Produkt weiterleitet und dieser den Barcode des Produkts übergibt. \newline

\noindent\textbf{Methode onCreateOptionsMenu(android.view.Menu menu)}

\noindent Die Methode onCreateOptionsMenu erzeugt das Menü für die AktionsLeiste Es wird zuerst überprüft ob der Nutzer eingeloggt ist. Nutzername und Password werden in einem User Objekt gespeichert. Das Menü "menu\_loggedin" wird hier verwendet. Der Nutzername wird in das Feld "action\_username" eingetragen und ein OnClickListener erstellt mit der Methode "goToProfile". Für den Logout Button wird ebenfalls ein OnClickListener erstellt, welcher den Nutzer ausloggt. Ist der Nutzer allgemein nicht eingloggt, so wird stattdessen das Standardmenü geladen. \newline

\noindent\textbf{Methode onOptionsItemSelected(android.view.MenuItem item)} 

\noindent Die Methode "onOptionsItemsSelected" wird ausgeführt, wenn ein Menüelement ausgewählt wurde. Je nachdem um welches Element es sich handelt werden unterschiedliche Aktionen ausgeführt. Bei "action\_search": Man wird zur Suche weitergeleitet. Bei "action\_login": Wenn eingeloggt, dann wird man zum Profil weitergeleitet. Wenn nicht eingeloggt, dann wird man zum Login weitergeleitet. Bei "action\_settings": Man wird zu den Einstellungen weitergeleitet. Bei "action\_info": Man wird zu den Informationen über die App weitergeleitet. Bei "action\_close": Die App wird beendet. \newline

\noindent\textbf{Methode addNewProduct()} 

\noindent Die Methode "addNewProduct" setzt einen OnClickListener auf den ActionButton "addNewProductActionButton" welcher auf die "CreateProductActivity" weiterleitet. \newline

\noindent\textbf{Methode goToProfile()} 

\noindent Die Methode "goToProfile" leitet einen zum Nutzerprofil weiter. \newline

\paragraph{CreateProductActivity}

Die Klasse "CreateProductActivity" ist dazu da um ein neues Produkt zu erstellen, welches in der lokalen SQLite Datenbank abgespeichert wird. \newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)} 

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Zunächst wird geprüft ob ein Barcode mit übergeben wurde. Wenn ein Barcode existiert, dann wird dem EditText "editBarcode" dieser als Text gesetzt. Es werden Werte initialisiert, zum Beispiel Buttons, TextViews oder EditText Felder. \newline

\noindent\textbf{Methode onCreateOptionsMenu(android.view.Menu menu)} 

\noindent Die Methode onCreateOptionsMenu erzeugt das Menü für die AktionsLeiste Es wird zuerst überprüft ob der Nutzer eingeloggt ist. Nutzername und Password werden in einem User Objekt gespeichert. Das Menü "menu\_loggedin" wird hier verwendet. Der Nutzername wird in das Feld "action\_username" eingetragen und ein OnClickListener erstellt mit der Methode "goToProfile". Für den Logout Button wird ebenfalls ein OnClickListener erstellt, welcher den Nutzer ausloggt. Ist der Nutzer allgemein nicht eingloggt, so wird stattdessen das Standardmenü geladen. \newline

\noindent\textbf{Methode onOptionsItemSelected(android.view.MenuItem item)} 

\noindent Die Methode "onOptionsItemsSelected" wird ausgeführt, wenn ein Menüelement ausgewählt wurde. Je nachdem um welches Element es sich handelt werden unterschiedliche Aktionen ausgeführt. Bei "action\_search": Man wird zur Suche weitergeleitet. Bei "action\_login": Wenn eingeloggt, dann wird man zum Profil weitergeleitet. Wenn nicht eingeloggt, dann wird man zum Login weitergeleitet. Bei "action\_settings": Man wird zu den Einstellungen weitergeleitet. Bei "action\_info": Man wird zu den Informationen über die App weitergeleitet. Bei "action\_close": Die App wird beendet. \newline

\noindent\textbf{Methode AddDataListener()} 

\noindent Die Methode "AddDataListener" erstellt einen OnClickListener für den Button "btnAdd". Es werden die Produktdaten in die lokale SQLite Datenbank übertragen. Zuerst wird überprüft ob das Feld für den Barcode leer ist. Ist dies der Fall wird eine aussagekräftige Fehlermeldung in ein TextView geladen. Ansonsten wird als nächstes versucht den Barcode in eine Long Variable umzuwandeln. Dies dient dazu, herauszufinden ob der Barcode numerisch ist. Ist dies nicht der Fall, wird eine aussagekräftige Fehlermeldung in ein TextView geladen. Als nächstes wird überprüft ob der Barcode bereits in der lokalen SQLite Datenbank oder in der Datenbank auf dem Server schon existiert. Ist dies der Fall, wird eine aussagekräftige Fehlermeldung in ein TextView geladen. Ist der Barcode noch nicht vorhanden so geht es weiter. Als nächstes wird überprüft ob der Name des Produkts leer ist. Ist dies der Fall, wird eine aussagekräftige Fehlermeldung in ein TextView geladen. Weiterhin wird überprüft ob der Bild URL leer ist. Ist dies der Fall, wird eine aussagekräftige Fehlermeldung in ein TextView geladen. Sind alle Produktdaten korrekt, dann werden diese in die lokale SQLite Datenbank übertragen. Wenn diese erfolgreich übertragen wurden, werden die Daten mit dem Server synchronisiert. Außerdem wird eine aussagekräftige Toast Nachricht erzeugt. Zum Schluss wird der Nutzer zurück zur "MainActivity" geleitet, falls er von da gekommen ist.\newline 

\noindent\textbf{Methode imageUploadListener()} 

\noindent Die Methode "imageUploadListener" setzt einen OnClickListener für den Button "btnImgUpload" und fragt die Erlaubnis für den Dateizugriff auf die Fotogalerie an.\newline 

\noindent\textbf{Methode takePhotoListener()} 

\noindent Die Methode "takePhotoListener" setzt einen OnClickListener für den Button "btnTakePhoto" und fragt die Erlaubnis für die Benutzung der Kamera an. \newline

\noindent\textbf{Methode imageUploadListener()} 

\noindent Die Methode "imageUploadListener" setzt einen OnClickListener für den Button "btnImgUpload" und fragt die Erlaubnis für den Dateizugriff auf die Fotogalerie an. \newline

\noindent\textbf{Methode requestCameraPermissions()} 

\noindent Die Methode "requestCameraPermissions" fragt die Erlaubnis für den Zugriff auf die Kamera an. Diese wird benötigt um Fotos vom Produkt zu machen und diese hochzuladen. \newline

\noindent\textbf{Methode deleteBarcodesListener()} 

\noindent Die Methode "deleteBarcodesListener" setzt einen OnClickListener auf den Button "btnDelete". Dieser ist standardgemäß ausgeblendet. Es werden alle Produkte aus der Datenbank gelöscht. \newline 

\noindent\textbf{Methode fillSpinnerWithCategoryData()} 

\noindent Die Methode "fillSpinnerWithCategoryData" füllt das DropDown Menü mit den Produktkategorien. Zuerst werden die Kategorien abgefragt und in ein String-Array gespeichert. Der aktuelle "categoryString" entspricht dem ersten Element des Arrays. Als nächstes wird ein ArrayAdapter erzeugt mit diesem String Array. Der ArrayAdapter wird anschließend für den "categorySpinner" gesetzt. Zum Schluss wird noch ein OnItemSelectedListener definiert, welcher den "categoryString" für jedes ausgewählte Element neu setzt. \newline

\noindent\textbf{Methode requestFilePermission()} 

\noindent Die Methode "requestFilePermissions" fragt die Erlaubnis für den Zugriff auf das Dateisystem an. Diese wird benötigt um die lokale Fotogalerie zu öffnen. \newline

\noindent\textbf{Methode onRequestPermissionsResult(int requestCode, \newline           java.lang.String[] permissions, int[] grantResults)} 

\noindent Die Methode "onRequestPermissionsResult" wird ausgeführt, wenn die Erlaubnis erteilt oder verweigert wurde. Wenn die Erlaubnis für das Dateisystem erteilt wurde, wird die Fotogalerie geöffnet. Wenn die Erlaubnis für die Kamera erteilt wurde, wird die Kamera geöffnet. \newline 

\noindent\textbf{Methode openCamera()} 

\noindent Die Methode "openCamera" erzeugt einen neuen Intent (ACTION\_IMAGE\_CAPTURE). Bevor die Kamera geöffnet wird, wird mithilfe der Methode "createPhotoFile" ein neuer Dateipfad für das Foto ezeugt, welches die Kamera aufnehmen wird, damit es lokal gespeichert werden kann. Anschließend wird der Pfad als URI an den Intent mit übergeben, welcher anschließend gestartet wird. Der Nutzer wird zur Kamera weitergeleitet. \newline

\noindent\textbf{Methode openFilePicker()} 

\noindent Die Methode "openFilePicker" öffnet die lokale Bildergalerie, also die Fotos welche auf dem Gerät gespeichert sind. Dazu wird ein neuer Intent erstellt (ACTION\_PICK) mit dem Type "image/*". Dieser wird anschließend gestartet. \newline

\noindent\textbf{Methode createPhotoFile()} 

\noindent Die Methode "createPhotoFile" erzeugt einen neuen Dateipfad für das Bild, welches von der Kamera aufgenommen wird. Dieser setzt sich aus dem Standardpfad für Bilder und dem Dateinamen zusammen. Der Dateiname wird mit "IMG\_" + "yyyMMdd\_HHmmss" + ".jpg" erzeugt. \newline

\noindent\textbf{Methode onActivityResult(int requestCode, int resultCode, \newline android.content.Intent data)} 

\noindent Die Methode "onActivityResult" wird ausgeführt, wenn der Nutzer wieder von der Kamera oder der Galerie zurück geleitet wurde. Es wird zunächst überprüft ob der Nutzer von der Kamera oder von der Galerie zurück geleitet wurde. Wenn der Nutzer von der Galerie zurück geleitet wurde, dann wird überprüft ob die übermittelten Daten nicht null sind (nullCheck()) und die URI erstellt, welche dem ausgewählten Bild entspricht. Wenn der Nutzer von der Kamera zurück geleitet wurde, dann ist der entsprechende Bildpfad, derjenige, welcher vor dem Aufruf der Kamera mit der Methode "createPhotoFile" erzeugt wurde. In beiden Fällen wird der Bildpfad in der Variable "imgUplPath" gespeichert. \newline

\noindent\textbf{Methode closeKeyboard()} 

\noindent Die Methode "closeKeyboard" schließt die Onscreen Tastatur. \newline 

\noindent\textbf{Methode goToProfile()} 

\noindent Die Methode "goToProfile" leitet einen zum Nutzerprofil weiter. \newline

\noindent\textbf{Methode goToMainActivity()} 

\noindent Die Methode "goToMainActivity" leitet einen zur "MainActivity" weiter. \newline

\newpage

\paragraph{ProductDetailActivity} Die Klasse "ProductDetailActivity" zeigt alle Einzelheiten zu einem Produkt an. \newline

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)} 

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Hier werden Werte initialisiert, zum Beispiel TextViews und Buttons. Der Barcode, welcher von der vorherigen Activity übergeben wurde, wird hier wieder von den Intent Extras übergeben. Mithilfe des Barcodes werden aus der lokalen SQLite Datenbank alle wichtigen Informationen zum Produkt abgefragt. Wenn keine Informationen gefunden werden, wird eine aussagekräftige Fehlermeldung angezeigt. Ansonsten werden die zum Produkt gefundenen Informationen in die TextViews geladen. Das Bild wird in die ImageView geladen. Es wird zusätzlich ein zweites Bild erzeugt, welches dem Barcode entspricht. Für die Buttons werden Methoden aufgerufen, welche OnClickListener festlegen. Wenn der Nutzer eingeloggt ist, dann werden die Buttons für das Hochladen von Fotos mithilfe der Kamera oder der lokalen Fotogalerie initialisiert. Am Ende wird der Preis mit der Methode "fetchCurrentPrice" abgefragt. \newline

\noindent\textbf{Methode onCreateOptionsMenu(android.view.Menu menu)} 

\noindent Die Methode onCreateOptionsMenu erzeugt das Menü für die AktionsLeiste Es wird zuerst überprüft ob der Nutzer eingeloggt ist. Nutzername und Password werden in einem User Objekt gespeichert. Das Menü "menu\_loggedin" wird hier verwendet. Der Nutzername wird in das Feld "action\_username" eingetragen und ein OnClickListener erstellt mit der Methode "goToProfile". Für den Logout Button wird ebenfalls ein OnClickListener erstellt, welcher den Nutzer ausloggt. Ist der Nutzer allgemein nicht eingloggt, so wird stattdessen das Standardmenü geladen. \newline

\noindent\textbf{Methode onOptionsItemSelected(android.view.MenuItem item)} 

\noindent Die Methode "onOptionsItemsSelected" wird ausgeführt, wenn ein Menüelement ausgewählt wurde. Je nachdem um welches Element es sich handelt werden unterschiedliche Aktionen ausgeführt. Bei "action\_search": Man wird zur Suche weitergeleitet. Bei "action\_login": Wenn eingeloggt, dann wird man zum Profil weitergeleitet. Wenn nicht eingeloggt, dann wird man zum Login weitergeleitet. Bei "action\_settings": Man wird zu den Einstellungen weitergeleitet. Bei "action\_info": Man wird zu den Informationen über die App weitergeleitet. Bei "action\_close": Die App wird beendet. \newline

\noindent\textbf{Methode productPhotosActionListener()} 

\noindent Die Methode "productPhotosActionListener" setzt einen OnClickListener für den Button "buttonProductPhotos", welcher den Nutzer zu den Produktfotos weiterleitet und den Barcode des Produkts mit übergibt. \newline

\noindent\textbf{Methode btnTakePhotoActionListener()} 

\noindent Die Methode "btnTakePhotoActionListener" setzt einen OnClickListener für den Button "btnTakePhoto" und fragt die Erlaubnis für die Benutzung der Kamera an. \newline

\noindent\textbf{Methode btnUploadImageActionListener()} 

\noindent Die Methode "btnUploadImageActionListener" setzt einen OnClickListener für den Button "btnImageUpload" und fragt die Erlaubnis für den Dateizugriff auf die Fotogalerie an. \newline 

\noindent\textbf{Methode requestFilePermission()} 

\noindent Die Methode "requestFilePermissions" fragt die Erlaubnis für den Zugriff auf das Dateisystem an. Diese wird benötigt um die lokale Fotogalerie zu öffnen. \newline

\noindent\textbf{Methode requestCameraPermissions()} 

\noindent Die Methode "requestCameraPermissions" fragt die Erlaubnis für den Zugriff auf die Kamera an. Diese wird benötigt um Fotos vom Produkt zu machen und diese hochzuladen. \newline 

\noindent\textbf{Methode onRequestPermissionsResult(int requestCode, \newline java.lang.String[] permissions, int[] grantResults)} 

\noindent Die Methode "onRequestPermissionsResult" wird ausgeführt, wenn die Erlaubnis erteilt oder verweigert wurde. Wenn die Erlaubnis für das Dateisystem erteilt wurde, wird die Fotogalerie geöffnet. Wenn die Erlaubnis für die Kamera erteilt wurde, wird die Kamera geöffnet. \newline 

\noindent\textbf{Methode openCamera()} 

\noindent Die Methode "openCamera" erzeugt einen neuen Intent (ACTION\_IMAGE\_CAPTURE). Bevor die Kamera geöffnet wird, wird mithilfe der Methode "createPhotoFile" ein neuer Dateipfad für das Foto ezeugt, welches die Kamera aufnehmen wird, damit es lokal gespeichert werden kann. Anschließend wird der Pfad als URI an den Intent mit übergeben, welcher anschließend gestartet wird. Der Nutzer wird zur Kamera weitergeleitet. \newline 

\noindent\textbf{Methode openFilePicker()} 

\noindent Die Methode "openFilePicker" öffnet die lokale Bildergalerie, also die Fotos welche auf dem Gerät gespeichert sind. Dazu wird ein neuer Intent erstellt (ACTION\_PICK) mit dem Type "image/*". Dieser wird anschließend gestartet. \newline 

\noindent\textbf{Methode createPhotoFile()} 

\noindent Die Methode "createPhotoFile" erzeugt einen neuen Dateipfad für das Bild, welches von der Kamera aufgenommen wird. Dieser setzt sich aus dem Standardpfad für Bilder und dem Dateinamen zusammen. Der Dateiname wird mit "IMG\_" + "yyyMMdd\_HHmmss" + ".jpg" erzeugt. \newline 

\noindent\textbf{Methode onActivityResult(int requestCode, \newline int resultCode, android.content.Intent data)} 

\noindent Die Methode "onActivityResult" wird ausgeführt, wenn der Nutzer wieder von der Kamera oder der Galerie zurück geleitet wurde. Wenn der resultCode OK ist, dann wird die Ladeanimation gestartet (loadingStart()) Es wird zunächst überprüft ob der Nutzer von der Kamera oder von der Galerie zurück geleitet wurde. Wenn der Nutzer von der Galerie zurück geleitet wurde, dann wird überprüft ob die übermittelten Daten nicht null sind (nullCheck()) und die URI erstellt, welche dem ausgewählten Bild entspricht. Wenn der Nutzer von der Kamera zurück geleitet wurde, dann ist der entsprechende Bildpfad, derjenige, welcher vor dem Aufruf der Kamera mit der Methode "createPhotoFile" erzeugt wurde. In beiden Fällen wird anschließend die Methode "imageUploadAction" aufgerufen. \newline 

\noindent\textbf{Methode btnAddPriceAction(java.lang.String barcode)} 

\noindent Die Methode "btnAddPriceAction" setzt einen OnClickListener für den Button "btnAddPrice". Der Nutzer soll die Möglichkeit haben einen Preis für das Produkt hinzuzufügen. Es wird ein neuer Intent erstellt, welcher auf die "CreatePriceActivity" weiterleitet. \newline

\noindent\textbf{Methode btnPriceHistoryAction(java.lang.String barcode)} 

\noindent Die Methode "btnPriceHistoryAction" setzt einen OnClickListener für den Button "btnPriceHistory". Der Nutzer wird auf den Preisverlauf des Produkts weitergeleitet. Es wird ein Intent erstellt, welcher auf die "PriceHistoryActivity" weiterleitet. \newline

\noindent\textbf{Methode btnTestAction(java.lang.String barcodeTest)} 

\noindent Die Methode "btnTestAction" setzt einen OnClickListener für den Button "btnTest". Zuerst wird überprüft ob das AR Model in der lokalen Datenbank vorhanden ist. Sollte es nicht vorhanden sein, so wird der Button "btnTest" deaktiviert, die Hintergrundfarbe auf Grau gesetzt und der Text des Buttons auf "No Model". Wenn ein Model existiert, dann wird ein OnClickListener für den Button "btnTest" erzeugt. Weiterhin wird überprüft ob die Einstellung "Ar Marker" aktiviert ist. Wenn Ja, dann wird der Nutzer auf die "ProductScanActivity" weitergeleitet Ansonsten wird der Nutzer auf die "ProductArActivity" weitergeleitet. \newline

\noindent\textbf{Methode btnDeleteAction(java.lang.String barcodeDelete)} 

\noindent Die Methode "btnDeleteAction" setzt einen OnClickListener für den Button "btnDelete". Das Produkt wird aus der lokalen Datenbank gelöscht und der Nutzer wird wieder zurück zur Produktübersicht geleitet. \newline

\noindent\textbf{Methode btnShareAction(java.lang.String name, java.lang.String barcode)} 

\noindent Die Methode "btnShareAction" setzt einen OnClickListener für den Button "btnShare". Der Nutzer hat die Möglichkeit die Produktinformationen zu teilen. Es wird ein Intent erzeugt (ACTION\_SEND) mit dem Type ("text/plain") Diesem wird die Nachricht zum Teilen übergeben. \newline 

\noindent\textbf{Methode btnRateAction(java.lang.String productName,\newline               java.lang.String barcode)} 

\noindent Die Methode "btnRateAction" setzt einen OnClickListener für den Button "btnRate". Der Nutzer hat die Möglichkeit das Produkt zu bewerten. \newline 

\noindent\textbf{Methode fetchCurrentRating(java.lang.String barcode)} 

\noindent Die Methode "fetchCurrentRating" fragt die Bewertungen für das Produkt ab. Der Barcode wird dann an die Methode "getAllRatingsForProduct" weitergegeben. Wenn die Ratings erfolgreich abgefragt wurden, wird der arithmetische Mittelwert ermittelt und dieser Wert an die RatingBar weitergeben. Die Ratingsbar zeigt nun die durchschnittliche Bewertung für ein Produkt an. \newline 

\noindent\textbf{Methode fetchCurrentPrice(java.lang.String barcode)} 

\noindent Die Methode "fetchCurrentPrice" fragt den aktuellen Preis des Produktes ab. Der Barcode wird dann an die Methode "getProductLatestPrice" weitergegeben. Wenn der Preis erfolgreich abgefragt wurde, wird die Währung ermittelt und das Währungssymbol abgefragt. Der Preis wird zusammen mit dem Währungssymbol in die TextView "detailPrice" eingefügt. Weiterhin wird der zugehörige Shop mithilfe der Methode "getShopFromPrice" abgefragt. Ist die Abfrage erfolgreich, dann wird der Name des Shops dem Preis angefügt. \newline

\noindent\textbf{Methode imageUploadAction()} 

\noindent Die Methode "imageUploadAction" lädt das Bild auf den Server hoch. Zuerst wird ein Multipart RequestBody mit der Datei (vom Bildpfad) erstellt. Dieser wird zusammen mit dem Barcode und den Login Daten an die Methode "uploadProductPhoto" von der Klasse "RetrofitCRUD" übergeben, welche das Bild an den Server überträgt. Wenn das Foto erfolgreich hochgeladen wurde, dann wird eine Toast Nachricht angezeigt. Wenn das Foto zu groß ist, oder keine Internetverbindung besteht wird ebenfalls eine aussagekräftige Fehlermeldung über eine Toast Nachricht angezeigt. In jedem Fall wird die Ladeanimation wieder beendet (loadingEnd()) \newline 

\noindent\textbf{Methode goToProfile()} 

\noindent Die Methode "goToProfile" leitet einen zum Nutzerprofil weiter. \newline

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{ProductPhotoGalleryActivity}
Die Klasse "ProductPhotoGalleryActivity" ist die Fotogallerie, welche die Fotos für ein Produkt in einer GridView anzeigt. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Es werden Werte initialisiert, wie zum Beispiel eine GridView. Als erstes erhält man den Barcode des Produkts, für welches man die Bilder abfragen möchte. Die Ladeanimation wird gestartet (loadingStart()). Als nächstes werden die Produktfotos vom Server abgefragt. Dazu wird der Barcode an die Methode "getProductPhotosByBarcode" übergeben Wenn die Anfrage erfolgreich war, dann werden die Fotos in einer Liste gespeichert. Es wird ein PhotoAdapter initialisiert und die Liste wird diesem übergeben. Anschließend wird für die GridView der Adapter gesetzt. Es wird noch ein OnItemClickListener für jedes Element in der GridView gesetzt, mit dem man dann auf die ProductPhotoDetailActivity weitergeleitet wird. Hierfür wird der Barcode und die Ressource URL des Fotos mit übergeben. In jedem Fall wird die Ladeanimation anschließend wieder beendet. \newline 

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{ProductPhotoDetailActivity} 
Die Klasse "ProductPhotoDetailActivity" zeigt ein Produktfoto in voller Größe an. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Der Barcode und die Ressource URL wird aus den Intent Extras abgefragt. Das Foto wird in die ImageView geladen. Es werden noch Buttons zum Teilen und Herunterladen des Bildes hinzugefügt. Wurde das Bild vom Nutzer selbst erstellt, dann wird ein zusätzlicher Button zum löschen des Bildes hinzugefügt. \newline

\noindent\textbf{Methode shareBtnAddListener()}

\noindent Die Methode "shareBtnAddListener" fügt einen OnClickListener für den Button "sharePhotoBtn" hinzu. Es wird ein Dateiname für das zu teilende Bild erzeugt. Als nächstes wird ein Intent (ACTION\_SEND) erstellt, welcher die URI des Bildes erhält. Zuvor wird das Bild jedoch lokal gespeichert, damit es geteilt werden kann. Als Type wird ("image/*") gesetzt. Zum Schluss wird der Intent gestartet. \newline 

\noindent\textbf{Methode downloadBtnAddListener()}

\noindent Die Methode "downloadBtnAddListener" fügt einen OnClickListener für den Button "downloadPhotoButton" hinzu. Mithilfe der Methode "saveImageBitmapUsingPicasso" wird das Bild lokal auf dem Gerät gesichert. \newline 

\noindent\textbf{Methode deleteBtnAddListener()}

\noindent Die Methode "deleteBtnAddListener" fügt einen OnClickListener für den Button "deletePhotoButton" hinzu. Über die Methode "deletePhoto" wird eine Anfrage an den Server geschickt mit der URL des Fotos und den Login Informationen. Ist die Anfrage erfolgreich, so wurde das Foto gelöscht und der Nutzer wird zurück zur Foto Galerie geleitet. \newline

\noindent\textbf{Methode galleryAddPic(java.lang.String saveFileName)}

\noindent Die Methode "galleryAddPic" fügt das Bild der Fotogalerie auf dem Gerät hinzu. \newline

\noindent\textbf{Methode saveImage(android.graphics.Bitmap image, java.lang.String fileName)}

\noindent Die Methode "saveImage" speicher das Bild lokal auf dem Gerät. \newline

\newpage

\paragraph{CreatePriceActivity}
Die Klasse "CreatePriceActivity" ist dazu da, dass der Nutzer einen Preis für das Produkt erstellen kann. Der Nutzer kann angeben, wie viel ein Produkt kostet, um welche Währung es sich handelt und bei welchen Geschäft er es entdeckt hat. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Es werden Werte initialisiert, zum Beispiel TextViews. Der Barcode wird aus den Intent Extras abgefragt. \newline

\noindent\textbf{Methode fillSpinnerWithCurrencyData()}

\noindent Die Methode "fillSpinnerWithCurrencyData" fügt die Währungen in ein Dropdown Menü ein. Die Namen der Währungen werden zuerst in einem String Array gespeichert. Der "currencyString" erhält zunächst den Wert des ersten Elements des Arrays. Es wird ein neuer ArrayAdapter initialisiert, welchem das String Array übergeben wird. Der Array Adapter wird anschließend für den "currencySpinner" gesetzt. Zuletzt wird ein onItemSelectedListener gesetzt, welcher den Wert für den "currencyString" dem gerade ausgewählten Wert setzt. \newline

\noindent\textbf{Methode fillSpinnerWithStoreData()}

\noindent Die Methode "fillSpinnerWithStoreData" fügt die Geschäfte in ein Dropdown Menü ein. Es wird zunächst eine Anfrage an den Server gestellt, welche alle Möglichen Geschäfte zu einem Produkt abfrägt. Wenn die Anfrage erfolgreich war, dann bekommt man als Antwort eine Liste an Shops. Als nächstes wird das Dropdown Menü für die Shops erstmal sichtbar gemacht. Alle Shopnamen werden dann in ein String Array gespeichert. Der "storeString" erhält zunächst den Wert des ersten Elements des String Arrays. Als nächstes wird ein ArrayAdapter initialisiert, welcher die Shopnamen erhält. Der Array Adapter wird anschließend für den "storeSpinner" gesetzt. Zuletzt wird ein OnItemSelectedListener gesetzt, welcher den Wert für den "storeString" dem gerade ausgewählten Wert setzt. \newline

\noindent\textbf{Methode validatePrice()}

\noindent Die Methode "validatePrice" validiert den Preis Als Kriterium muss dieser erfüllen: - Der Preis darf nicht leer sein - Der Preis darf eine Länge von 8 Zeichen nicht überschreiten \newline 

\noindent\textbf{Methode validateStore()}

\noindent Die Methode "validateStore" validiert das eingegebene Geschäft. Als Kriterium muss dieses erfüllen: - Geschäft darf nicht leer sein. - Name des Geschäfts darf nicht länger als 50 Zeichen sein. \newline 

\noindent\textbf{Methode validateStoreString()}

\noindent Die Methode "validateStoreString" validiert den String, welcher durch das Dropdown Menü ausgewählt wurde. Als Kriterium muss dieser erfüllen: - Der "storeString" darf nicht leer sein. \newline 

\noindent\textbf{Methode confirmPrice(android.view.View v)}

\noindent Die Methode "confirmPrice" überprüft ob alle Nutzereingaben zum Preis auch valide sind. Wenn der "storeString" nicht valide ist und entweder der Preis oder das Geschäft invalide sind, dann wird die Methode zurückgegeben. Wenn der Wert des EditText Feldes für den Store leer ist, dann wird zunächst überprüft ob der Preis valide ist. Ist der Preis invalide wird die Methode zurückgegeben. Weiterhin wird überprüft, ob der "storeString" valide ist. Ist dieser ebenfalls invalide, so wird die Methode zurückgegeben, ansonsten wird dieser weiterverwendet. Nun wird die Ladeanimation gestartet (loadingStart()) Zum Schluss wird die Methode "createPriceAndReturnToDetailActivity" ausgeführt. \newline 

\noindent\textbf{Methode createPriceAndReturnToDetailActivity(java.lang.String price, \newline java.lang.String currency,                                                java.lang.String store)}

\noindent Die Methode "createPriceAndReturnToDetailActivity" sendet die Preisinformationen an den Server und leitet den Nutzer zurück zur "ProductDetailActivity" Zunächst werden alle wichtigen Informationen in eine Map gespeichert: - Barcode - Preis - Währung - Geschäft Als nächstes wird die Map an die Methode "createPriceForProduct" weitergegeben, welche die Anfrage an den Server schickt. Ist die Anfrage fehlgeschlagen, dann wird eine aussagekräftige Toast Nachricht erzeugt. Wenn die Anfrage erfolgreich gewesen ist, dann wird der Nutzer zurück zur "ProductDetailActivity" geleitet, welcher der Barcode übergeben wird. In jedem Fall wird die Ladeanimation wieder beendet (loadingEnd()) \newline 

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{PriceHistoryActivity}
Die Klasse "PriceHistoryActivity" zeigt dem Nutzer den Preisverlauf des Produkts an. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Es werden Werte initialisiert, wie zum Beispiel eine GraphView. Zuerst wird die Ladeanimation gestartet. Als nächstes wird der Barcode aus den Intent Extras abgefragt. Dieser wird der Methode "getProductPrices" übergeben, welche eine Anfrage an den Server schickt. Wenn die Anfrage erfolgreich war, dann wird eine Liste von Preisen als Antwort vom Server zurückgegeben. Wenn diese nicht "null" ist (nullCheck()), nicht leer ist und mindestens 2 Elemente beinhaltet, dann wir eine LineGraphSeries initialisiert, welcher Werte (Datenpunkte (x,y)) hinzugefügt werden können. Die Preise werden mit aufsteigenden x-Werten je einem y-Wert zugeordnet. Nun muss die maximale Anzahl an Datenpunkten für die x-Achse noch einmal manuel gesetzt werden. Anschließend wird die LineGraphSeries dem "priceHistoryGraph" hinzugefügt. Somit werden alle Werte in Form eines einfachen Graphes visualisiert. In jedem Fall wird die Ladeanimation wieder beendet (loadingEnd()) \newline

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{CreateRatingActivity}
Die Klasse "CreateRatingActivity" ist dafür da, dass Nutzer eine Bewertung für ein Produkt erstellen können. \newline 

\noindent\textbf{Methode onCreate(@Nullable android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Es werden wichtige Variablen initialisiert wie zum Beispiel eine RatingBar oder ein Textfeld. Außerdem werden die Methoden "ratingStarsListener()" und "rateButtonListener" aufgerufen. \newline

\noindent\textbf{Methode fillWithUserRating()}

\noindent Die Methode "fillWithUserRating" füllt die RatingBar und das Textfeld mit der zuvor abgegebenen Bewertung des Nutzers aus, falls diese existiert, damit der Nutzer die Möglichkeit hat die Bewertung zu bearbeiten. \newline 

\noindent\textbf{Methode ratingStarsListener()}

\noindent Die Methode "ratingStarsListener" setzt einen OnRatingBarChangeListener für die RatingBar. In dem Fall wird die Anzahl der Sterne bei einer Bewertung in die int Variable stars gespeichert. \newline 

\noindent\textbf{Methode rateButtonListener()}

\noindent Die Methode "rateButtonListener" setzt einen OnClickListener für den "rateButton". Zuerst wird die Methode "validateRatingInput" aufgerufen, wenn diese true zurückliefert, wird die Eingabe an den Server geschickt, die Bewertung wird dann auf den Server gespeichert. \newline 

\noindent\textbf{Methode validateRatingInput()}

\noindent Die Methode "validateRatingInput" validiert die Eingabe der RatingBar und des Textfeldes. Diese besitzt folgende Vorgaben: - RatingBar muss mindestens einmal bewertet worden sein und - Anzahl der Sterne dürfen nicht 0 sein. - Text des Rating Reviews darf nicht leer sein. \newline 

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{ProductSearchActivity}
Die Klasse "ProductSearchActivity" stellt die Suchfunktion zur Verfügung. Die Datenbank auf dem Server kann komplett nach Produkten durchsucht werden. \newline 

\noindent\textbf{Methode onCreate(@Nullable android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Hier werden wichtige Werte initialisiert, wie zum Beispiel eine ListView oder ein Textfeld für die Suche. Mithilfe eines "addTextChangedListeners" und eines "TextWatchers" lässt sich eine Methode aufrufen sobald der Nutzer eine Änderung am Textfeld vorgenomen hat. Sind Suchergebnisse vorhanden, wird die ListView nun mit den Produkten, welche auf dem Server gefunden wurden, gefüllt. Ansonsten wird eine TextView angezeigt, dass keine Suchergebnisse gefunden wurden. Sobald der Nutzer auf ein Element der ListView tippt, wird er, sollte das Produkt lokal schon existieren direkt zur "ProductDetailActivity" weitergeleitet, ansonsten wird das Produkt erst heruntergeladen und der Nutzer wird nach einer kurzen Zeit auf die "ProductDetailActivity weitergeleitet. \newline 

\noindent\textbf{Methode goToProductDetailActivity(java.lang.String itemBarcode)}
 
\noindent Die Methode "goToProductDetailActivity" leitet einen auf die Informationsseite des Produktes weiter. \newline

\noindent\textbf{Methode showNoSearchResult()}
 
\noindent Die Methode "showNoSearchResult" blendet die ListView aus und zeigt stattdessen eine TextView an mit der Nachricht, dass keine Suchergebnisse gefunden wurden. \newline 

\noindent\textbf{Methode hideNoSearchResult()}
 
\noindent Die Methode "hideNoSearchResult" blendet die TextView (keine Suchergebnisse) wieder aus. \newline 


\newpage

\paragraph{RegisterActivity}
Die Klasse "RegisterActivity" ist dafür da, dass sich Nutzer ein Konto anlegen können um sich dann später in der App einloggen zu können. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Es werden Werte initialisiert: TextInputLayout: - Email - Nutzername - Passwort - Passwort wiederholen \newline 

\noindent\textbf{Methode validateEmail()}
 
\noindent Die Methode "validateEmail" validiert die E-Mail Adresse. Als Kriterium muss diese erfüllen: - E-Mail Adresse darf nicht leer sein - E-Mail Adresse muss @-Zeichen enthalten \newline 

\noindent\textbf{Methode validateUsername()}
 
\noindent Die Methode "validateUsername" validiert den Benutzernamen. Als Kriterium muss dieser erfüllen: - Benutzername darf nicht leer sein - Benutzername darf nicht länger als 25 Zeichen sein \newline 

\noindent\textbf{Methode validatePassword()}
 
\noindent Die Methode "validatePassword" validiert das Passwort. Als Kriterium muss dieses erfüllen: - Passwort darf nicht leer sein. \newline

\noindent\textbf{Methode validateRepeatPassword()}
 
\noindent Die Methode "validateRepeatPassword" validiert das vom Nutzer doppelt eingegebene Passwort. Als Kriterium muss dieses erfüllen: - Doppeltes Passwort darf nicht leer sein - Doppeltes Passwort muss dem Passwort entsprechen \newline 

\noindent\textbf{Methode confirmInput(android.view.View v)}
 
\noindent Diese Methode überprüft alle Eingaben des Nutzers und wird zurückgegeben, wenn eine Eingabe invalide sein sollte. Sind alle Eingaben valide, wird die Methode "createUser" ausgeführt. \newline 

\noindent\textbf{Methode createUser()}
 
\noindent Die Methode "createUser" legt ein Nutzerkonto auf dem Server an. Dass Passwort wird vorher mit MD5 verschlüsselt. Die Werte E-Mail, Nutzername und Passwort werden in eine Map übertragen, welche an die Methode "createUser" übergeben wird. Diese stellt nun die Anfrage an den Server. Ist die Anfrage erfolgreich, so wird eine aussagekräftige Toast Nachricht erzeugt. In jedem Fall wird die Methode "clearTextFields" aufgerufen. \newline 

\noindent\textbf{Methode clearTextFields()}
 
\noindent Die Methode "clearTextFields" löscht alle Nutzereingaben aus den Textfeldern. \newline



\paragraph{LoginActivity}
Die Klasse "LoginActivity" stellt einen "Anmeldebildschirm" zur verfügung. Sie ist dazu da, dass sich der Nutzer mit seinem Konto in der App anmelden kann. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Es werden Werte initialisiert für die Felder Nutzername, Password sowie eine CheckBox. Weiterhin wird ein Button für die Registrierung eines Kontos hinzugefügt. \newline 

\noindent\textbf{Methode addRegisterButton()}

\noindent Die Methode "addRegisterButton" fügt einen OnClickListener für den Button "register\_button" hinzu. Es wird ein Intent erstellt, welcher den Nutzer auf die RegisterActivity weiterleitet. \newline

\noindent\textbf{Methode validateUsername()}

\noindent Die Methode "validateUsername" validiert den Benutzernamen. Als Kriterium muss dieser erfüllen: - Benutzername darf nicht leer sein - Benutzername darf nicht länger als 25 Zeichen sein \newline 

\noindent\textbf{Methode validatePassword()}

\noindent Die Methode "validatePassword" validiert das Passwort Als Kriterium muss dieses erfüllen: - Das Passwort darf nicht leer sein. \newline 

\noindent\textbf{Methode confirmLogin(android.view.View v)}

\noindent Wenn der Nutzername oder das Password invalide ist, dann wird die Methode zurückgegeben. Die Ladeanimation startet. Der Nutzername und das Passwort wird aus den EditText Feldern der TextInputLayouts zwischengespeichert. Das Passwort wird mit MD5 verschlüsselt. Anschließend wird die Methode "loginUser" aufgerufen. \newline 

\noindent\textbf{Methode loginUser(java.lang.String username, \newline                     java.lang.String password, boolean stayLoggedIn)}

\noindent Die Methode "loginUser" vergleicht die Login Informationen, welche vom Nutzer eingegeben wurden mit denen, welche sich auf dem Server befinden. Mithilfe der Methode "loginUser" wird eine Anfrage über Retrofit an den Server gestellt. Ist die Anfrage erfolgreich, so wird der Nutzer auf die "ProfileActivity" weitergeleitet. Ist stayLoggedIn true, dann werden die Anmeldedaten mithilfe des LoginHelpers in den SharedPreferences gespeichert. In jedem Fall wird die Ladeanimation wieder beeendet (loadingEnd()) \newline

\noindent\textbf{Methode clearTextFields()}

\noindent Die Methode "clearTextFields" löscht alle Nutzereingaben aus den Textfeldern. Sie wird hier nicht verwendet, da der Nutzer die Möglichkeit haben sollte, bei einem gescheiterten Anmeldeversuch den Nutzername oder Passwort ausbessern zu können. \newline 

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\newpage

\paragraph{ProfileActivity}
Die Klasse "ProfileActivity" zeigt das Nutzerprofil an, sowie alle wichtigen Informationen. Darunter zählen: - E-Mail Adresse - Nutzername - Bild Außerdem gibt es die Möglichkeit ein neues Bild hochzuladen. Weiterhin hat der Nutzer die Möglichkeit sein Konto wieder zu löschen. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der Activity ausgeführt. Hier werden Werte gesetzt, wie zum Beispiel TextViews. Über die Intent Extras wird der Nutzername und das Passwort übergeben. Die Ladeanimation startet (loadingStart()) Mithilfe der Methode "getUserByUsernameAndPassword" wird eine Anfrage an den Server erstellt, welcher alle wichtigen Nutzerinformationen abfrägt. Für den Fall dass diese nicht erfolgreich ist, wird eine aussagekräftige Toast Nachricht erzeugt und die Activity beendet. Wenn die Anfrage erfolgreich war, dann wird der Nutzername, die E-Mail Adresse sowie das Bild des Nutzers geladen. Zum Schluss werden die Methoden "btnChooseFileAction" und "btnDeleteAction" ausgeführt. \newline 

\noindent\textbf{Methode btnChooseFileAction()}

\noindent Die Methode "btnChooseFileAction" setzt einen OnClickListener für den Button "btnImageUpload". Die Methode "requestFilePermission" wird augeführt. \newline 

\noindent\textbf{Methode btnDeleteAction()}

\noindent Die Methode "btnDeleteAction" setzt einen OnClickListener für den Button "btnDelete". Es wird ein AlertDialog erstellt, in dem der Nutzer gefragt wird, ob er sein Konto wirklich löschen möchte. \newline 

\noindent\textbf{Methode requestFilePermission()}

\noindent Die Methode "requestFilePermissions" fragt die Erlaubnis für den Zugriff auf das Dateisystem an. Diese wird benötigt um die lokale Fotogalerie zu öffnen. Die Methode "openFilePicker" wird ausgeführt, wenn die Erlaubnis vorliegt. \newline 

\noindent\textbf{Methode onRequestPermissionsResult(int requestCode, \newline              java.lang.String[] permissions, int[] grantResults)}

\noindent Die Methode "onRequestPermissionsResult" wird ausgeführt, wenn die Erlaubnis erteilt oder verweigert wurde. Wenn die Erlaubnis für das Dateisystem erteilt wurde wird die Fotogalerie geöffnet. \newline

\noindent\textbf{Methode openFilePicker()}

\noindent Die Methode "openFilePicker" öffnet die lokale Bildergalerie, also die Fotos welche auf dem Gerät gespeichert sind. Dazu wird ein neuer Intent erstellt (ACTION\_PICK) mit dem Type "image/*". Dieser wird anschließend gestartet. \newline 

\noindent\textbf{Methode onActivityResult(int requestCode, \newline int resultCode, android.content.Intent data)}

\noindent Die Methode "onActivityResult" wird ausgeführt, wenn der Nutzer von der Galerie wieder zurück geleitet wurde. Wenn der result code OK ist und die übermittelten Daten nicht null sind (nullCheck()) wird eine URI erstellt, welche dem ausgewählten Bild entspricht. Anschließend wird die Methode "imageUploadAction" aufgerufen. \newline

\noindent\textbf{Methode imageUploadAction()}

\noindent Die Methode "imageUploadAction" lädt das Bild auf den Server hoch. Zuerst wird ein Multipart RequestBody mit der Datei (vom Bildpfad) erstellt. Dieser wird zusammen mit dem Barcode und den Login Daten an die Methode "uploadProductPhoto" von der Klasse "RetrofitCRUD" übergeben, welche das Bild an den Server überträgt. Wenn das Foto erfolgreich hochgeladen wurde, dann wird eine Toast Nachricht angezeigt. Wenn das Foto zu groß ist, oder keine Internetverbindung besteht wird ebenfalls eine aussagekräftige Fehlermeldung über eine Toast Nachricht angezeigt. In jedem Fall wird die Ladeanimation wieder beendet (loadingEnd()) \newline 

\noindent\textbf{Methode loadingStart()}

\noindent Die Methode "loadingStart" startet die Ladeanimation. \newline

\noindent\textbf{Methode loadingEnd()}

\noindent Die Methode "loadingEnd" beendet die Ladeanimation. \newline

\paragraph{SettingsActivity}
Die Klasse "SettingsActivity" sind die Einstellungen. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Start der Activity ausgeführt. Es wird ein "SettingsHelper" und eine "DatabaseHelper" initialisiert. Als nächstes wird die Methode "configureSettingsElements" aufgerufen. \newline 

\noindent\textbf{Methode configureSettingsElements()}

\noindent Die Methode "configureSettingsElements" konfiguriert die Einstellungen. Als erstes wird die Einstellung für den Switch "ArMarker" konfiguriert. Dazu wird der aktuelle Wert der SharedPreferenes über den "SettingsHelper" abgefragt. Als letztes wird ein onCheckedChangeListener erstellt, welcher bei einer Änderung diese in den "SettingsHelper" wieder unter den SharedPreferences abspeichert. Analog passiert dies auch für den Switch für die "Special Deals". Für die "dealPercentage" wird die Methode "fillDealPercentageSpinner" aufgerufen. Für das "dealInterval" wird die Methode "fillDealIntervalSpinner" aufgerufen. Zuletzt wird die gesamte Anzahl aller Scans aus der lokalen Datenbank abgefragt und angezeigt. \newline 

\noindent\textbf{Methode fillDealPercentageSpinner()}

\noindent Die Methode "fillDealPercentageSpinner" fügt die Prozentzahlen für die Deal Notifications in ein Dropdown Menü ein. Das Array mit den Prozentzahlen wird zuerst vom "PriceHelper" abgefragt. Es wird ein neuer ArrayAdapter initialisiert, welchem das String Array übergeben wird. Der Array Adapter wird anschließend für "dealPercentage" gesetzt. Als aktuelle Auswahl wird der in den SharedPreferences gespeicherte Wert aus dem "SettingsHelper" ausgelesen. Zuletzt wird ein OnItemSelectedListener gesetzt, welcher den gerade ausgewählten Wert für "dealPercentage" wieder mithilfe des SettingsHelpers abspeichert. \newline 

\noindent\textbf{Methode fillDealIntervalSpinner()}

\noindent Die Methode "fillDealIntervalSpinner" fügt das Interval für die Deal Notifications in ein Dropdown Menü ein. Zuerst wird ein String Array mit den möglichen Intervallen erstellt. Es wird ein neuer ArrayAdapter initialisiert, welchem das String Array übergeben wird. Der Array Adapter wird anschließend für "dealInterval" gesetzt. Als aktuelle Auswahl wird der in den SharedPreferences gespeicherte Wert aus dem "SettingsHelper" ausgelesen. Zuletzt wird ein OnItemSelectedListener gesetzt, welcher den gerade ausgewählten Wert für "dealInterval" wieder mithilfe des SettingsHelpers abspeichert. \newline 

\noindent\textbf{Methode btnShowModelsAction()}

\noindent Die Methode "btnShowModelsAction" setzt einen OnClickListener für den Button "showModelsBtn" Es werden alle Modelle von der lokalen SQLite Datenbank abgefragt und angezeigt. \newline

\paragraph{InfoActivity}
Die Klasse "InfoActivity" zeigt die App Infos an (z.B. Icon, Version, Author) \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten der App ausgeführt. Es wird die Versionsnummer bestimmt und für die TextView "app\_version" gesetzt. \newline 

\subsubsection{Fragment Klassen}

\paragraph{ScanFragment}
Die Klasse "ScanFragment" ist ein Fragment für das Scannen von Barcodes. \newline 

\noindent\textbf{Methode onCreate(android.os.Bundle savedInstanceState)}

\noindent Die Methode "onCreate" wird beim Starten des Fragments ausgeführt. \newline 

\noindent\textbf{Methode checkPermission()}

\noindent Die Methode "checkPermission" überprüft ob die Erlaubnis für die Benutzung der Kamera erteilt wurde. \newline 

\noindent\textbf{Methode requestPermission()}

\noindent Die Methode "requestPermission" fragt die Erlaubnis für die Benutzung der Kamera an. \newline 

\noindent\textbf{Methode onRequestPermissionsResult(int requestCode, \newline              java.lang.String[] permission, int[] grantResults)}

\noindent Die Methode "onRequestPermissionsResult" wird aufgerufen nachdem die Abfrage für die Erlaubnis der Kamerabenutzung stattgefunden hatte. \newline 

\noindent\textbf{Methode onActivityResult(int requestCode, \newline 
int resultCode, android.content.Intent intent)}

\noindent Die Methode "onActivityResult" wird ausgeführt wenn ein Barcode gescannt wurde. \newline 

\noindent\textbf{Methode displayAlertMessage(java.lang.String message, \newline         android.content.DialogInterface.OnClickListener listener)}

\noindent Die Methode "displayAlertMessage" generiert einen Fehlerdialog. \newline 

\paragraph{CustomArFragment}
Die Klasse "CustomArFragment" ist ein ArFragment, welches in der "ProductScanActivity" verwendet wird. \newline 

\noindent\textbf{Methode getSessionConfiguration(com.google.ar.core.Session session)}

\noindent Die Methode getSessionConfiguration wurde überschrieben. \newline 

\subsubsection{Adapter Klassen}

\paragraph{ProductListAdapter}
Die Klasse "ProductListAdapter" stellt eine Adapterklasse dar für die Produktelemente, welche in der "LastScannedProductsActivity" in einer ListView angezeigt werden. \newline 

\noindent\textbf{Innere Klasse ViewHolder}

\noindent ViewHolder Klasse, welche folgendes enthält: TextView name, TextView barcode, TextView scannedAt, ImageView image. \newline 

\noindent\textbf{Methode getView(int position, \newline                                android.view.View convertView, android.view.ViewGroup parent)}

\noindent Die Methode "getView" wird von der Klasse "ArrayAdapter" überschrieben. Zuerst werden die Produktinformationen in lokale Variablen gespeichert. Als nächstes wird ein Produkt erzeugt mit den entsprechenden Variablen. Weiterhin wird ein ViewHolder initialisiert. Dieser wird in den nächsten Schritten mit den Informationen des Produktes gefüllt. Es wird eine Animation für das Laden von weiteren Elementen festgelegt. Das Bild des Produktes wird in die dafür vorgesehene ImageView geladen. \newline 

\paragraph{SearchListAdapter}
Die Klasse "SearchListAdapter" stellt eine Adapterklasse dar für die Produktelemente, welche in der "SearchProductActivity" in einer ListView angezeigt werden. \newline 

\noindent\textbf{Innere Klasse ViewHolder}

\noindent ViewHolder Klasse, welche folgendes enthält: TextView name, TextView category, RatingBar rating, ImageView image. \newline 

\noindent\textbf{Methode getView(int position, \newline                                android.view.View convertView, android.view.ViewGroup parent)}

\noindent Die Methode "getView" wird von der Klasse "ArrayAdapter" überschrieben. Zuerst werden die Produktinformationen in lokale Variablen gespeichert. Als nächstes wird ein Produkt erzeugt mit den entsprechenden Variablen. Weiterhin wird ein ViewHolder initialisiert. Dieser wird in den nächsten Schritten mit den Informationen des Produktes gefüllt. Es wird eine Animation für das Laden von weiteren Elementen festgelegt. Das Bild des Produktes wird in die dafür vorgesehene ImageView geladen. Die durchschnittliche Bewertung des Produkts wird berechnet und der Wert wird in der RatingBar des ViewHolders gesetzt. \newline 

\paragraph{PhotoAdapter}
Die Klasse "ProductListAdapter" stellt eine Adapterklasse dar für die Fotos, welche in der "ProductPhotoGalleryActivity" in einer GridView angezeigt werden. \newline 

\noindent\textbf{Methode getCount()}

\noindent Gibt die Anzahl der Fotos zurück. \newline 

\noindent\textbf{Methode getItem(int position)}

\noindent Gibt das Foto zurück, welches sich an einer bestimmten Position befindet. \newline 

\noindent\textbf{Methode getItemId(int position)}

\noindent Methode "getItemId" gibt die Id eines Items zurück. \newline 

\noindent\textbf{Methode getPhotos()}

\noindent Alle Fotos bekommen. \newline 

\noindent\textbf{Methode setPhotos(java.util.List<Photo> photos)}

\noindent Liste Fotos setzen. \newline 

\noindent\textbf{Methode addPhoto(Photo photo)}

\noindent Einzelnes Foto hinzufügen. \newline 

\noindent\textbf{Methode removePhoto(Photo photo)}

\noindent Einzelnes Foto entfernen. \newline 

\noindent\textbf{Methode getView(int position, \newline                              android.view.View convertView, android.view.ViewGroup parent)}

\noindent Methode "getView" Das Foto wird in die dafür vorgesehene ImageView in der GridView geladen. \newline 

\newpage

\subsubsection{Hilfs Klassen}

\paragraph{GeneralHelper}
Die Klasse "GeneralHelper" enthält allgemeine Variablen und Hilfsmethoden. \newline 

\noindent\textbf{Methode toastMessage(java.lang.String message, \newline                   android.content.Context context)}

\noindent Die Methode "toastMessage" sendet eine Toast Message \newline

\noindent\textbf{Methode showMessage(java.lang.String title,\newline  java.lang.String message, android.content.Context context)}

\noindent Die Methode "showMessage" zeigt einen Fehlerdialog an. \newline

\noindent\textbf{Methode alertDialog(java.lang.String message, \newline  android.content.Context context)}

\noindent Die Methode "alertDialog" zeigt einen Fehlerdialog an. \newline

\noindent\textbf{Methode getTimestampStringNow()}

\noindent Die Methode "getTimestampStringNow" gibt den aktuellen Timestamp in Form eines Strings aus. \newline 

\noindent\textbf{Methode convertFromTimestamp(java.lang.String timestamp)}

\noindent Die Methode "convertFromTimestamp" gibt den Timestamp als String an im folgenden Format: DD.MM.YYYY HH:II:SS \newline 

\noindent\textbf{Methode convertFromTimestampWithoutSec(java.lang.String timestamp)}

\noindent Die Methode "convertFromTimestampWithoutSec" gibt den Timestamp als String an im folgenden Format: DD.MM.YYYY HH:II \newline 

\noindent\textbf{Methode TimestampIsBefore(java.lang.String timestamp\_a, \newline          java.lang.String timestamp\_b)}

\noindent Die Methode "TimestampIsBefore" überprüft ob ein Timestamp zeitlich vor einem anderen Timestamp liegt. \newline

\noindent\textbf{Methode MD5(java.lang.String md5)}

\noindent Die Methode "MD5" generiert einen MD5 Hashwert für einen bestimmten Eingabestring. \newline

\noindent\textbf{Methode getRealPathFromUri(android.net.Uri uri, \newline                  android.content.Context context)}

\noindent Die Methode "getRealPathFromUri" gibt den Pfad einer Uri zurück. \newline

\noindent\textbf{Methode getNames(java.lang.Class $\langle? extends java.lang.Enum\langle?\rangle\rangle$ e)}

\noindent Die Methode "getNames" gibt die Namen eines Enums in Form eines String Arrays zurück. \newline 

\noindent\textbf{Methode getPositionFromStringArray(java.lang.String[] array, \newline
                                             java.lang.String elem)}

\noindent Die Methode "getPositionFromStringArray" gibt die Position eines Elements in einem Stringarray zurück. \newline 

\noindent\textbf{Methode nullCheck(java.lang.Object obj)}

\noindent Die Methode "nullCheck" überprüft ob ein Objekt null ist / ob ein Objekt existiert / initialisiert wurde. \newline 

\noindent\textbf{Methode nullToString(java.lang.Object input)\newline}
\noindent\textbf{Methode nullToString(java.lang.Integer input)\newline}
\noindent\textbf{Methode nullToString(java.lang.Long input)\newline}
\noindent\textbf{Methode nullToString(java.lang.Double input)\newline}
\noindent\textbf{Methode nullToString(java.lang.String input)\newline}

\noindent Die Methode "nullToString" fügt den Platzhalter "null" ein wenn ein Objekt in einer Ausgabe null sein sollte. \newline 

\noindent\textbf{Methode getVersionNumber(android.content.Context context)}

\noindent Die Methode "getVersionNumber" fragt die Version der App ab.\newline 

\paragraph{BarcodeHelper}
Die Klasse "BarcodeHelper" bietet Hilfsmethoden für Barcodes an. \newline 

\noindent\textbf{Methode encodeAsBitmap(java.lang.String contents, \newline          com.google.zxing.BarcodeFormat format, int img\_width, int img\_height) \newline 
throws com.google.zxing.WriterException}

\noindent Die Methode "encodeAsBitmap" wandelt den Barcode in ein Bild um. \newline 

\noindent\textbf{Methode guessAppropriateEncoding(java.lang.CharSequence contents)}

\noindent Die Methode "guessAppropriateEncoding" ist eine Hilfsmethode für die Methode "encodeAsBitmap". \newline 

\noindent\textbf{Methode generateBarCodeCode128(java.lang.String data)}

\noindent Die Methode "generateBarCodeCode128" generiert ein Bild von einem Barcode im Format CODE128. \newline 

\noindent\textbf{Methode generateBarCodeEAN(java.lang.String data)}

\noindent Die Methode "generateBarCodeEAN" generiert ein Bild von einem Barcode im Format EAN\_13. \newline 


\paragraph{QRCodeHelper}
Die Klasse QRCodeHelper bietet Hilfsmethoden für QR Codes an. \newline 

\noindent\textbf{Methode qrCreateBitmap(java.lang.String str)}

\noindent Die Methode "qrCreateBitmap" erstellt ein Bild von einem QR Code. \newline 

\paragraph{LoginHelper}
Die Klasse LoginHelper verwaltet wichtige Login Variablen sowie den gespeicherten Login. \newline 

\noindent\textbf{Methode saveLogin(java.lang.String username, \newline                      java.lang.String password, android.content.Context \_\_context)}

\noindent Die Methode "saveLogin" speichert die Login Daten in den sharedPreferences. \newline 

\noindent\textbf{Methode checkIfSharedPrefsExistsAndNotEmpty( \newline android.content.Context \_\_context)}

\noindent Die Methode "checkIfSharedPrefsExistsAndNotEmpty" überprüft ob die gespeicherten Login Daten existieren und nicht leer sind. \newline 

\noindent\textbf{Methode getSharedUsername(android.content.Context \_\_context)}

\noindent Die Methode "getSharedUsername" gibt den gespeicherten Benutzernamen zurück. \newline 

\noindent\textbf{Methode getSharedPassword(android.content.Context \_\_context)}

\noindent Die Methode "getSharedPassword" gibt das gespeicherte Passwort zurück. \newline 

\noindent\textbf{Methode doLogout(android.content.Context \_\_context)}

\noindent Die Methode "doLogout" meldet den Benutzer ab. \newline

\paragraph{SettingsHelper}
Die Klasse SettingsHelper verwaltet die gespeicherten Einstellungen. \newline 

\noindent\textbf{Methode saveBoolean(java.lang.String key,                     java.lang.Boolean value)}

\noindent Die Methode "saveBoolean" speichert eine Boolean in den sharedPreferences ab. \newline 

\noindent\textbf{Methode saveString(java.lang.String key, java.lang.String value)}

\noindent Die Methode "saveString" speichert einen String in den sharedPreferences ab. \newline 

\noindent\textbf{Methode saveArSwitch(java.lang.Boolean switchValue)}

\noindent Die Methode "saveArSwitch" speichert den Wert des Switches "ArMarker" ab. \newline

\noindent\textbf{Methode saveSpecialDeal(java.lang.Boolean specialDeal)}

\noindent Die Methode "saveSpecialDeal" speichert den Wert des Switches "SpecialDealNotifications" ab. \newline 

\noindent\textbf{Methode saveDealPercentage(java.lang.String dealPercentage)}

\noindent Die Methode "saveDealPercentage" speichert den Wert (in Prozent) für Deals ab. \newline 

\noindent\textbf{Methode saveInterval(java.lang.String interval)}

\noindent Die Methode "saveInterval" speichert den Wert des Intervals für die Notifications ab. \newline 

\noindent\textbf{Methode getArSwitch()}

\noindent Die Methode "getArSwitch" gibt den aktuellen Zustand für den Switch "ArMarker" zurück. \newline 

\noindent\textbf{Methode getSpecialDeal()}

\noindent Die Methode "getSpecialDeal" gibt den aktuellen Zustand für den Switch "SpecialDealNotifications" zurück. \newline 

\noindent\textbf{Methode getSpecialDealPercentage()}

\noindent Die Methode "getSpecialDealPercentage" gibt den aktuellen Wert (in Prozent) für Deals zurück. \newline 

\noindent\textbf{Methode getSpecialDealInterval()}

\noindent Die Methode "getSpecialDealInterval" gibt das Interval für die Notifications zurück. \newline 


\paragraph{ImageHelper}
Die Klasse "ImageHelper" stellt eine generelle Hilfsklasse für Bilder dar. \newline 

\noindent\textbf{Methode getBitmapFromURL(java.lang.String src)}

\noindent Die Methode "getBitmapFromURL" gibt ein Bild von einer Ressource url zurück. \newline 

\noindent\textbf{Methode saveImageBitmapUsingPicasso(java.lang.String image\_ressource, \newline 
java.lang.String title,
java.lang.String description, \newline 
android.content.ContentResolver contentResolver, \newline 
android.content.Context context)}

\noindent Die Methode "saveImageBitmapUsingPicasso" speichert ein Bild ab. \newline 

\noindent\textbf{Methode setImageViewLocalImage(java.lang.String imagePath, \newline android.widget.ImageView imageView)}

\noindent Die Methode "setImageViewLocalImage" lädt ein lokales Bild in eine ImageView. \newline 

\noindent\textbf{Methode isRemoteImage(java.lang.String imagePath)}

\noindent Die Methode isRemoteImage überprüft ob es sich um ein Bild aus dem Internet handelt. \newline 

\noindent\textbf{Methode getBitmapFromView(android.widget.ImageView imageView)}

\noindent Die Methode getBitmapFromView gibt das Bild von einer ImageView zurück. \newline 

\noindent\textbf{Methode getRightAngleImage(java.lang.String photoPath)}

\noindent Die Methode "getRightAngleImage" ermittelt, wie ein Bild gedreht ist (0 Grad, 90 Grad, 180 Grad, 270 Grad). \newline 

\noindent\textbf{Methode rotateImage(int degree,                                     java.lang.String imagePath)}

\noindent Die Methode "rotateImage" dreht ein Bild. \newline

\paragraph{PhotoHelper}
Die Hilfsklasse "PhotoHelper" enthält wichtige Hilfsmethoden und Variablen für die Fotogallerie. \newline 

\noindent\textbf{Methode userCheck(java.lang.String photo\_ressource\_string, \newline       java.lang.String barcode)}

\noindent Die Methode "userCheck" überprüft ob das Bild des Produkts vom Nutzer selbst hinzugefügt wurde. Nur dieser kann es löschen. \newline 

\paragraph{UploadHelper}
Die Hilfsklasse "UploadHelper" enthält alle wichtigen Variablen für den Upload einer Datei. \newline 

\paragraph{PriceHelper}
Die Hilfsklasse "PriceHelper" enthält alle wichtigen Variablen und Methoden für den Preis eines Produktes. \newline

\newpage

\subsubsection{Retrofit Schnittstelle}

Die Klasse "RetrofitCRUD", welche die Methoden des Interfaces "IRetrofitCRUD" implementiert, stellt die Methoden für Retrofit zur Verfügung und ist die Schnittstelle zum Backend Server. \newline 

\noindent\textbf{Im Folgenden eine Übersicht der Methoden:}

\noindent

\begin{figure}[h]
\centering
\includegraphics[width=450px]{img/retrofit_crud_method_overview.png}
\caption{Methoden der Klasse \textbf{RetrofitCRUD}}
\end{figure}

\subsubsection{Network Monitor}
Die Klasse "NetworkMonitor" überwacht die Netzwerkaktivität. Bei entsprechenden Änderungen werden Aktionen ausgeführt. \newline

\noindent\textbf{Methode onReceive(android.content.Context context,\newline               android.content.Intent intent)}

\noindent Die Methode "onReceive" wird aufgerufen wenn sich der Netzwerkstatus geändert hat. \newline 

\noindent\textbf{Methode checkNetworkConnection(android.content.Context context)}

\noindent Die Methode "checkNetworkConnection" überprüft ob eine Internetverbindung besteht. \newline 

\noindent\textbf{Methode syncData(android.content.Context context)}

\noindent Die Methode "syncData" synchronisiert die erstellten Produkte mit der Datenbank auf dem Server. \newline 

\noindent\textbf{Methode syncScanCount(android.content.Context context,\newline            java.lang.String syncedBarcode, int scanCount)}

\noindent Die Methode "syncScanCount" synchronisiert die Anzahl der Scans. \newline

\noindent\textbf{Methode syncNewProductImage(android.content.Context \_\_context, \newline   java.lang.String uploadBarcode, java.lang.String imageUrlPath)}

\noindent Die Methode "syncNewProductImage" synchronisiert das Bild des Produkts. \newline 

\subsubsection{Background Service}
Die Klasse "ProductDealJobService" ist ein JobService für Benachrichtungen zu aktuellen Deals für Produkte. \newline 

\noindent\textbf{Methode onStartJob(android.app.job.JobParameters params)}

\noindent Die Methode "onStartJob" wird beim ausführen des Jobs ausgeführt. \newline 

\noindent\textbf{Methode onStopJob(android.app.job.JobParameters params)}

\noindent Die Methode "onStopJob" wird ausgeführt wenn der Job abgebrochen wurde. \newline 

\noindent\textbf{Methode doBackgroundWork(android.app.job.JobParameters params))}

\noindent Die Methode "doBackgroundWork" fragt beim Server an ob es für die auf dem Smartphone gespeicherten Produkte Sonderangebote gibt. Bei einem Sonderangebot werden entsprechende Push Benachrichtungen angezeigt. \newline 

\subsubsection{Notifications}
Die Klasse "SendNotification" ist eine Hilfsklasse zum versenden von Benachrichtigungen. \newline 

\noindent\textbf{Methode sendDealPushNotification(java.lang.String title, \newline         java.lang.String notificationMessage,                                    android.content.Intent startIntent)}

\noindent Die Methode "sendDealNotification" sendet eine Benachrichtigung für ein Produkt mit einem Sonderangebot. \newline 

\subsection{Ressourcen}

\subsubsection{Layout}

\paragraph{activity\_main} \mbox{} 

\noindent Das Layout für die Activity "MainActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt. Weiterhin gibt es ein TextView, welches folgenden Text beinhaltet: "Scan a Bar Code". In der Mitte befindet sich eine ImageView in der ein Platzhalter eingefügt ist. Nach dem Scan kann hier das Produktbild eingefügt werden. Schließlich gibt es noch einen Button "Scan Now" mit dem die Methode "scanNow" aufgerufen wird. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_create\_price} \mbox{} 

\noindent Das Layout für die Activity "CreatePriceActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Add Price"). Als nächstes gibt es einen TextInputLayout, in dem der Preis numerisch angegeben werden kann. Das nächste Element ist ein Dropdown Menü, welches die Währung bestimmt. Weiterhin gibt es ein TextInputLayout für das Geschäft. Zum Schluss ist ein grüner Button mit folgenden Text "ADD". Am unteren Bildschirmrand befindet sich die Navigation-Bar. 

\paragraph{activity\_create\_product} \mbox{} 

\noindent Das Layout für die Activity "CreateProductActivity". Als erstes existiert eine TextView ("Create a new Product"). Als nächstes gibt es eine TextView ("Barcode") mit einem EditText in dem der Barcode eingetragen werden kann. Als nächstes Element gibt es eine TextView ("Name") mit einem EditText in der der Name des Produktes eingetragen werden kann. Weiterhin gibt es ein Dropdown Menü mit TextView ("Category") in welcher eine Produktkategorie ausgewählt werden kann. Als nächstes Kann mit dem Button "Take Photo" ein Bild aufgenommen oder mit dem Button "Open Gallery" ein Bild aus der lokalen Fotogallerie ausgewählt werden. Zum Schluss gibt es noch einen grünen Button "Create Product". Dieser erstellt das Produkt. Am unteren Bildschirmrand befindet sich die Navigation-Bar. 

\paragraph{activity\_create\_rating} \mbox{} 

\noindent Das Layout für die Activity "CreateRatingActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Rate Product"). Als nächstes gibt es eine TextView, welche einen Platzhalter enthält, in welcher der Produktname angezeigt wird. Als nächstes Element gibt es eine TextView "Stars" mit einer RatingBar, welche zum Bewerten des Produktes verwendet wird. Weiterhin gibt es eine TextView ("Review"), welches von einem EditText gefolgt wird, in dem ein Review für das Produkt verfasst werden kann. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_info} \mbox{} 

\noindent Das Layout für die Activity "InfoActivity". Ganz oben befindet sich eine ImageView mit dem App Logo. als nächstes kommt eine TextView mit dem Namen der App. Darunter befindet sich eine weitere TextView, welche einen Platzhalter für die App Version enthält. Darunter eine TextView mit dem Namen des Autors. Schließlich gibt es noch eine TextView mit der Matrikelnummer und der E-Mail Adresse des Autors. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_last\_scanned} \mbox{} 

\noindent Das Layout für die Activity "LastScannedProductsActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Last scanned Products"). Darunter befindet sich direkt die ListView, welches die Produkte enthält. Weiterhin gibt es einen grünen FloatingActionButton um ein Produkt neu anzulegen. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_login} \mbox{} 

\noindent Das Layout für die Activity "LoginActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Login"). Es gibt ein TextInputLayout für den Benutzernamen, welches auf 25 Zeichen begrenzt ist. Darunter ist ein TextInputLayout für das Passwort, welches jedoch die Zeichen ausblendet. Darunter gibt es eine CheckBox mit dem Label "Stay logged in". Schließlich gibt es zwei Buttons, einen gründen "Login" Button und einen normalen "Create Account" Button. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_price\_history} \mbox{} 

\noindent Das Layout für die Activity "PriceHistoryActivity". Es wird ein TextView angezeigt "Not enough data." wenn nicht genügend Daten vorhanden sind. Ansonsten gibt es noch eine GraphView, welche den Preisverlauf anzeigt. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_ar} \mbox{} 

\noindent Das Layout für die Activity "ProductArActivity". Das Hauptelement ist das AR Fragment, welches vom Typ "com.google.ar.sceneform.ux.ArFragment" ist. dies füllt die ganze Fläche komplett aus. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_detail} \mbox{} 

\noindent Das Layout für die Activity "ProductDetailActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Product Details"). Darunter gibt es folgende TextViews: Label für Name, Name mit Platzhalter "\_\_name\_of\_product\_\_", Label für Kategorie, Kategorie mit Platzhalter "\_\_catg\_of\_product\_\_", Label für Bewertung, Platzhalter "Not rated yet.". Als nächstes Element ist die TextView für das Produktbild "Image" und die ImageView darunter, welche einen Platzhalter für das Produktbild beinhaltet. In der Activity wird das entsprechende Produktbild hier eingefügt. Als nächstes kommmt der Button um weitere Produktfotos anzuschauen. Es gibt auch zwei weitere Buttons, jedoch sind diese nur sichtbar, wenn der Nutzer eingeloggt ist: "Take Photo" um ein Foto aufzunehmen und hochzuladen und "open gallery" um die Fotogallerie zu öffnen und ein Foto auszuwählen und anschließend hochzuladen. Darunter ist die TextView als Label für den Barcode und der Barcode, welcher als Platzhalter sich darunter befindet "\_\_barcode\_\_". Darunter befindet sich das Label für den Preis mit dem Preis als Platzhalter darunter "No current price.". Weiterhin gibt es 2 Buttons "Add Price" um einen Preis hinzufügen und "Price History" um sich den Preisverlauf des Produktes anzuschauen. Als nächstes ist das Label für das Datum des Scans inklusive Platzhalter "\_\_timestamp\_\_". Anschließend gibt es 4 Buttons. "Test in AR" in blau, um das Produkt in AR Testen zu können. "Share" um das Produkt zu teilen. "Delete" um das Produkt lokal löschen zu können. Der Button "Rate" wird nur angezeigt, wenn der Nutzer eingeloggt ist und befindet sich zwischen "Test in AR" und "Share". Er ist dazu zuständig, damit der Nutzer das Produkt bewerten kann. Zum Schluss gibt es noch eine TextView, welche rechtsbündig verläuft und die Anzahl der Scans im folgenden Format anzeigt "7 mal gescannt". Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_photo\_detail} \mbox{} 

\noindent Das Layout für die Activity "ProductPhotoDetailActivity". Als Hauptelement wird hier eine ImageView verwendet, welches das Bild in voller Größe anzeigt. Weiterhin gibt es 3 FloatingActionButtons, ein roter zum löschen des Bildes, welcher jedoch nur angezeigt wird, wenn das Bild vom Nutzer selbst erstellt wurde. Ein blauer um das Bild zu teilen. Der letzte ist grau und ist dafür da, dass das Bild heruntergeladen werden kann. Alle FloatingActionButtons befinden sich am rechten unteren Bildschirmrand. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_photo\_gallery} \mbox{} 

\noindent Das Layout für die Activity "ProductPhotoGalleryActivity". Als Hauptelement wird hier eine GridView verwendet, welche 3 Bilder nebeneinander in einer Reihe aufnehmen kann. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_scan} \mbox{} 

\noindent Das Layout für die Activity "ProductScanActivity". Das Hauptelement ist das AR Fragment, welches vom Typ "de.nimoo.productar.fragments.CustomArFragment" ist. dies füllt die ganze Fläche komplett aus. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_product\_search} \mbox{} 

\noindent Das Layout für die Activity "ProductSearchActivity". Am oberen Bildschirmrand befindet sich ein EditText, welches eine Suchleiste darstellt. Unterstrichen wird dies noch einmal mit einer ImageView, welche sich am linken Rand des EditTextes befindet und ein Drawable in Form einer Lupe enthält. Darunter befindet sich eine ListView, in welches die Suchelemente geladen werden. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_profile} \mbox{} 

\noindent Das Layout für die Activity "ProfileActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("User Profile"). Darunter ist sind weitere TextViews: Label für Username, Username und Label für E-Mail, E-Mail. Darunter ist das Label für das Profilbild "Profile Image", welches sich direkt darunter befindet. Für das Profilbild wurde ebenfalls wieder ein Platzhalter verwendet, welcher angezeigt wird, falls der Nutzer kein Bild hat. Darunter ist ein Button "Upload Image" welcher die Fotogallerie öffnet um ein neues Profilbild auszuwählen. Darunter ist ein roter Button "Delete Account" mit dem der Nutzer sein Konto löschen kann. Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_register} \mbox{} 

\noindent Das Layout für die Activity "RegisterActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Create Account"). Darunter gibt es ein TextInputLayout für die E-Mail. Als nächstes Element gibt es einen TextInputLayout für den Nutzernamen, welches auf 25 Zeichen begrenzt ist. Darunter sind noch einmal 2 TextInputLayout Elemente, welches für das Passwort und zum Wiederholen des Passworts gedacht ist. Bei der Eingabe werden die Zeichen ausgeblendet. Darunter ist ein grüner Button "Create Account". Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{activity\_settings} \mbox{} 

\noindent Das Layout für die Activity "SettingsActivity". Es gibt ein TextView, welches die Überschrift der Activity darstellt ("Settings"). Als nächstes gibt es eine TextView, welche eine neue Kategorie darstellt "AR Settings". Das erste Element ist eine TextView "AR Marker" und ein Switch. Darunter befindet sich zwei TextViews, welche die API Version angeben. Das nächste Element ist eine TextView "Show downloaded AR Models" mit einem Button, welcher die gespeicherten AR Modelle anzeigt. Als nächstes gibt es eine TextView, welche eine neue Kategorie darstellt "Notifications". Das erste Element ist eine TextView "SpecialDeals" mit einem Switch. Als nächstes kommt ein TextView "Deal \%" mit einem Dropdown Menü. Als letztes in der Kategorie gibt es noch das TextView "Interval" mit einem Dropdown Menü. Die Letzte Kategorie ist "General Info". Hier gibt es ein TextView "TotalScans" und eines rechts daneben, welches die Anzahl der aller Scans insgesamt anzeigt. Zum Schluss gibt es noch eine TextView mit grauer Schrift "(c) 2019 ProductAR". Am unteren Bildschirmrand befindet sich die Navigation-Bar.

\paragraph{adapter\_view\_layout} \mbox{} 

\noindent Das Layout für den Adapter "ProductListAdapter". Links befindet sich eine ImageView mit einem Platzhalter für das Produktbild. In der Mitte ist eine TextView, welche für den Namen des Produktes bestimmt ist. Auf der rechten Seite gibt es 2 TextViews, welche sich untereinander befinden, eine für den Barcode und eine für den Timestamp.

\paragraph{search\_adapter\_view\_layout} \mbox{} 

\noindent Das Layout für den Adapter "SearchListAdapter". Links befindet sich eine ImageView mit einem Platzhalter für das Produktbild. In der Mitte ist eine TextView, welche für den Namen des Produktes bestimmt ist. Auf der rechten Seite gibt es 2 Elemente untereinander. Eine TextView, welche für die Produktkategorie bestimmt ist und eine RatingBar, welche die durchschnittliche Bewertung für ein Produkt nur anzeigt.

\paragraph{spinner\_spimple\_item} \mbox{} 

\noindent Das Layout für ein einfaches Dropdown Menü. 

\paragraph{list\_layout} \mbox{} 

\noindent Das Layout für die Activity "ListDataActivity". Kann ignoriert werden.

\subsubsection{Drawable Icons}

Im Ordner "drawable" befinden sich Icons, welche innerhalb der App, beispielsweise in einem Layout, verwendet werden.

\newpage

\subsubsection{App Icon}

Das Logo der App befindet sich auf dem Pfad ''/res/mipmap''. Mithilfe des Asset Studios in Android Studio lassen sich eigene Logos und andere Icons erstellen, ebenfalls auch Ladeanimationen. Das Logo der App wurde mit dem Asset Studio generiert und hat einen blauen Hintergrund sowie ein Drawable Icon in der Mitte (Vordergrund). Ein weiterer Vorteil ist, dass das Logo für alle verschiedenen Größen und Formate generiert wird. (z.B. auch runde Logos).

\begin{figure}[h]
\centering
\includegraphics[width=150px]{img/app_icon.png}
\caption{Logo der App "ProductAR"}
\end{figure}

\subsubsection{Animation}

\paragraph{SplashScreen} \mbox{} \newline

\noindent Hierfür werden die beiden XML Dateien "fade\_in" und "fade\_out" verwendet. Mit "fade\_out" wird der SplashScreen ausgeblendet und mit "fade\_in" der Übergang zur MainActivity eingeblendet.

\paragraph{Übergang zu einer neuen Activity} \mbox{} \newline 

\noindent Es gibt 2 mögliche Animationen zum Übergang zu einer neuen Activity. \newline 

\noindent \textbf{Mit "slide\_in\_left" und "slide\_out\_right"} wird die neue Activity von links in das Bild geschoben und die vorherige Activity verschwindet nach rechts. \newline 

\noindent \textbf{Mit "slide\_in\_right" und "slide\_out\_left"} wird die neue Activity von rechts in das Bild geschoben und die vorherige Activity verschwindet nach links. \newline 

\newpage

\paragraph{Laden neuer Elemente einer ListView} \mbox{} \newline

\noindent Es gibt hierbei auch 2 mögliche Animationen. \newline 

\noindent \textbf{Mit "load\_down\_anim"} wird ein neues Element von oben nach unten eingeschoben. \newline 

\noindent \textbf{Mit "load\_up\_anim"} wird ein neues Element von unten nach oben eingeschoben. \newline 


\subsubsection{Menu}

\noindent \textbf{bottom\_nav\_menu \newline}
\noindent Es handelt sich hierbei um das Layout für Navigationsmenü am unteren Rand des Bildschirms, welches die 3 Schaltflächen "Test Product" (links), "Scan Barcode" (Mitte), "Products" (rechts) beinhaltet. \newline 

\noindent \textbf{menu\_home \newline}
\noindent Das Layout "menu\_home" ist für das Menü zuständig, welches sich ganz oben in der App, jedoch noch unterhalb der Android Statusleiste befindet. Es wird für Nutzer, welch sich nicht in der App angemeldet haben angezeigt. Menüelemente, welche direkt angezeigt werden sind: Suchsymbol, Nutzersymbol. Weiterhin gibt es ein Dropdown Menü, welches folgende Elemente beeinhaltet: "Settings", "Info" und "Exit". \newline

\noindent \textbf{menu\_logged\_in \newline}
\noindent Das Layout "menu\_logged\_in" ist für das Menü zuständig, welches sich ganz oben in der App, jedoch noch unterhalb der Android Statusleiste befindet. Es wird für Nutzer, welch sich eingeloggt haben angezeigt. Menüelemente, welche direkt angezeigt werden sind: Suchsymbol, Nutzersymbol und Nutzername. Weiterhin gibt es ein Dropdown Menü, welches folgende Elemente beeinhaltet: "Settings", "Info", "Logout" und "Exit". \newline

\newpage 

\subsubsection{Assets}

Der Ordner "Assets" befindet sich außerhalb des Ressource Ordners. Dennoch habe ich ihn mit in diese Kategorie genommen, da hier wichtige Ressourcen liegen. Hier werden die 3D Modelle für die AR Szene ("ProductArActivity" und "ProductScanActivity") gespeichert. \newline 

\noindent \textbf{Als Platzhalter} falls kein Produkt zum Testen ausgewählt wurde, wird in der "ProductArActivity" oder "ProductScanActivity" ein leerer Einkaufswagen in AR angezeigt. \newline 
\begin{figure}[h]
\centering
\includegraphics[width=320px]{img/cart.JPG}
\caption{Einkaufswagen in AR}
\end{figure}

\subsubsection{Values}

In diesem Ordner sind Dateien, welche String Variablen oder Konstanten enthalten, Dimensions Vorgaben, Farb und Style Vorgaben. Hier kann beispielsweise ein API Key gespeichert werden, falls in Zukunft die Google Maps API in der App verwendet wird.

\newpage

\subsection{Rest Api}
Im Folgenden werden alle Möglichkeiten der Rest Schnittstelle noch einmal dokumentiert. Es werden keine Klassen oder Methoden beschrieben sondern der Pfad welcher auf dem Webserver existiert.

\subsubsection{Pfad ../}

Auf diesem Pfad befindet sich die Datenschutzerklärung der App (index.php), welche für einen Eintrag im Google Play Store erforderlich ist.

\subsubsection{Pfad ../products/}

\paragraph{Hauptpfad}

Auf dem Hauptpfad befindet sich eine index.php \newline 

\noindent\textbf{GET: Keine Parameter}
 
\noindent Alle Produkte werden im JSON Format ausgegeben. \newline 

\noindent\textbf{GET: ?productid=1}

\noindent Das Produkt mit der Id "1" wird im JSON Format ausgegeben. \newline 

\noindent\textbf{GET: ?barcode=1234567890128}

\noindent Das Produkt mit dem Barcode "1234567890128" wird im JSON Format ausgegeben. \newline 

\noindent \textbf{GET: ?search=banan}

\noindent Produkte welche die Zeichenkette "banan" im Namen oder im Barcode enthalten werden im JSON Format ausgegben. Dabei spielt die Groß- und Kleinschreibung keine Rolle. \newline

\noindent \textbf{POST: Parameter: name, barcode, image, barcode, loginusername, loginpassword}

\noindent Ein Produkt wird auf dem Server gespeichert, wenn es noch nicht vorhanden ist. Ist es bereits vorhanden, so wird nur eine Produkt-Nutzer Referenz hinzugefügt. \newline

\noindent \textbf{POST: scancount, scanbarcode, scanusername, scanpasswd}

\noindent Die Anzahl an Scans werden für einen Nutzer aktualisiert.

\paragraph{Unterpfad ../products/images/}
Auf diesem Pfad befindet sich eine index.php. \newline 

\noindent \textbf{POST: product\_title\_img, product\_title\_img\_barcode, \newline  product\_title\_img\_username, product\_title\_img\_password}

\noindent Ein neues Produktbild wird auf den Server hochgeladen.

\newpage

\paragraph{Unterpfad ../products/photos/}
Auf diesem Pfad befindet sich eine index.php. \newline 

\noindent \textbf{GET: Keine Parameter}

\noindent Alle Fotos zu den Produkten werden im JSON Format ausgegeben, beginnend mit dem neuesten. \newline 

\noindent \textbf{GET: ?barcode=1234567890128}

\noindent Alle Fotos zu dem Produkt mit dem Barcode "1234567890128" werden im JSON Format ausgegeben, beginnend mit dem neuesten. \newline 

\noindent \textbf{POST: product\_img, product\_img\_barcode, \newline product\_img\_username, product\_img\_password}

\noindent Nutzer welche eingeloggt sind können neue Fotos zu einem Produkt hochladen. \newline

\noindent \textbf{POST: delete\_img\_url, delete\_img\_username, delete\_img\_password}

\noindent Nutzer welche eingeloggt sind können Ihre hochgeladenen Fotos zu einem Produkt wieder löschen.

\paragraph{Unterpfad ../products/prices/}

Auf diesem Pfad befindet sich eine index.php. \newline 

\noindent \textbf{GET: ?barcode\_latest\_price=1234567890128}

\noindent Der letzte Preis zu dem Produkt mit dem Barcode "1234567890128" wird abgefragt und im JSON Format zurückgegeben. \newline 

\noindent \textbf{GET: ?barcode\_cheapest\_price=1234567890128}

\noindent Der günstigste Preis zu dem Produkt mit dem Barcode "1234567890128" wird abgefragt und im JSON Format zurückgeben. \newline 

\noindent \textbf{GET: ?barcode\_prices=1234567890128}

\noindent Alle Preise zu dem Produkt mit dem Barcode "1234567890128" werden abgefragt und im JSON Format zurückgegeben. \newline 

\noindent \textbf{GET: ?price\_shop\_id=5}

\noindent Gibt den Shop mit der Id "5" im JSON Format aus. \newline

\noindent \textbf{GET: ?price\_shop\_barcode=1234567890128}

\noindent Gibt alle verfügbaren Shops für den Barcode "1234567890128" im JSON Format zurück. \newline

\noindent \textbf{GET: ?price\_deal\_barcode=1234567890128\&price\_deal\_percentage=0.5}

\noindent Gibt an ob das Produkt (mit dem Barcode "1234567890128") gerade im Sonderangebot ist (0.5 bedeutet 50\% Rabatt). Hierbei wird der aktuelle Preis mit dem ursprünglichen UVP verglichen. Wenn das Produkt im Angebot ist wird "Special Deal!" ausgegeben, ansonsten "No Special Deal!". \newline

\noindent \textbf{POST: Parameter: price\_barcode, price\_value, price\_currency, price\_shop}

\noindent Ein neuer Preis wird für das Produkt mit dem Barcode "1234567890128" in die Datenbank geschrieben.

\paragraph{Unterpfad ../products/ratings/}
Auf diesem Pfad befindet sich eine index.php. \newline

\noindent \textbf{GET: Keine Parameter}

\noindent Gibt alle Bewertungen im JSON Format zurück. \newline

\noindent \textbf{GET: ?barcode=1234567890128}

\noindent Gibt alle Bewertungen für das Produkt mit dem Barcode "1234567890128" im JSON Format zurück. \newline

\noindent \textbf{GET: ?barcode=1234567890128\newline\&username=test\&password=e10adc3949ba59abbe56e057f20f883e}

\noindent Gibt die Bewertung des Nutzers "test" für das Produkt mit dem Barcode "1234567890128" im JSON Format zurück. \newline 

\noindent \textbf{POST: new\_rating\_barcode, new\_rating\_stars, \newline new\_rating\_review, new\_rating\_username, new\_rating\_password}

\noindent Erstellt eine neue Bewertung von einem Nutzer für ein Produkt. Wenn schon bereits eine Bewertung für den Nutzer existiert, dann wird diese aktualisiert.\newline  

\subsubsection{Pfad ../users/}

\paragraph{Hauptpfad} 
Auf dem Hauptpfad befindet sich eine index.php \newline 

\noindent \textbf{GET: ?username=test\&password=e10adc3949ba59abbe56e057f20f883e}

\noindent Es wird geprüft ob die Anmeldedaten (Benutzer: "test", Passwort: MD5("123456")) mit den Informationen in der Datenbank übereinstimmen. Wenn Ja, dann wird die Nachricht "Successfully logged in!" ausgegeben, ansonsten die Nachricht "Login failed! Username or Password incorrect!". \newline

\noindent \textbf{GET: ?username=test\&password=e10adc3949ba59abbe56e057f20f883e\&profile=profile}
Wenn die Informationen für den Login stimmen, dann wird das Nutzerprofil im JSON Format zurückgegeben. \newline

\noindent \textbf{POST: username, email, password}

\noindent Ein neuer Benutzer wird registriert. \newline 

\paragraph{Unterpfad ../users/images/}

Auf diesem Pfad befindet sich eine index.php. \newline 

\noindent \textbf{POST: profile\_img, profile\_img\_username, profile\_img\_password}

\noindent Ein neues Profilbild für einen Nutzer wird hochgeladen.


\subsubsection{Pfad ../models/}

\paragraph{Hautpfad}
 
Auf dem Hauptpfad befindet sich eine index.php \newline 

\noindent \textbf{GET: ?productid=1}

\noindent  Das Model für das Produkt mit der Id "1" wird im JSON Format zurückgegben.

\newpage

\section{Veröffentlichung im Google Play Store}

\subsection{Store Eintrag}

Die App ist unter folgendem Link im Google Play Store erreichbar: \newline \url{https://play.google.com/apps/testing/de.nimoo.productar}

\begin{figure}[h]
\centering
\includegraphics[width=150px]{img/store_screenshot.png}
\caption{Screenshot des Eintrags im Google Play Store}
\end{figure}

\paragraph{Kurzbeschreibung} \mbox{} \newline 
\noindent Eine App mithilfe der man Produkte scannen und testen kann 

\paragraph{Beschreibung} \mbox{} \newline 
\noindent Die App hat folgende Features: \newline 

\noindent - Barcodes von Produkten scannen \newline 
\noindent - Produkte lokal hinzufügen \newline 
\noindent - Informationen über Produkte erhalten \newline 

\noindent - Produkte Testen [BETA] \newline 

\noindent Bald im Play Store verfügbar! \newline

\subsection{Screenshots}

Im folgenden die Screenshots, welche dem Eintrag im Google Play Store angefügt wurden. \newline 

\begin{figure}[h]
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_1.png}
      \caption{MainActivity}
   \end{minipage}
   \hspace{.1\linewidth}% Abstand zwischen Bilder
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_2.png}
      \caption{Products}
   \end{minipage}
   \hspace{.1\linewidth}% Abstand zwischen Bilder
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_3.png}
      \caption{Details}
   \end{minipage}
\end{figure}

\begin{figure}[h]
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_4.png}
      \caption{AR}
   \end{minipage}
   \hspace{.1\linewidth}% Abstand zwischen Bilder
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_5.png}
      \caption{Photos}
   \end{minipage}
   \hspace{.1\linewidth}% Abstand zwischen Bilder
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_6.png}
      \caption{Create}
   \end{minipage}
\end{figure}

\newpage

\begin{figure}[h]
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_7.png}
      \caption{Search}
   \end{minipage}
   \hspace{.1\linewidth}% Abstand zwischen Bilder
   \begin{minipage}[b]{.2\linewidth} % [b] => Ausrichtung an \caption
      \includegraphics[width=100px]{img/screenshots/screenshot_8.png}
      \caption{Info}
   \end{minipage}
\end{figure}

\subsection{Alpha Test}

Zuerst wurde ein geschlossener Track für den Alpha Test erstellt. Nur bestimmte Leute, welche per E-Mail zu dem Test eingeladen werden, können daran teilnehmen.

\subsection{Beta Test}

Der Betatest ist offen für jeden, der den Link zur App besitzt. Er wurde am 27.06.2019 eingeführt. 

\subsection{Testen im Ikea in Würzburg}

Zum Testen der App wurden einige Produkte im Ikea eingescannt und Fotos sowie Preise hinzugefügt. Dies wurde mit 2 Smartphones (Samsung Galaxy S8) getestet und jeweils in einem mobilen Netz oder im Ikea internen Wlan. Ziel war es herauszufinden, wie schnell Produkte online verfügbar sind, so dass der andere sie wieder scannen kann und wie schnell die Bilder, welche man von den Produkten angefertigt hat, laden. Hierbei ist man zu dem Ergebnis gekommen, dass die Bilder relativ langsam übertragen werden, da sie vom Smartphone in einer relativ guten Qualität geschossen werden und daher eine erhöhte Dateigröße aufweisen.

\newpage

\section{Zukünftige Entwicklungen}

\subsection{Erweiterungen}

\noindent Die App kann dahingehend erweitert werden, dass AR Modelle während der Laufzeit aus dem Internet geladen und direkt in der Welt platziert werden können. Aktuell ist hierbei die Ladezeit / Latenz ein großes Problem, die das Modell zum herunterladen benötigt, weshalb das Feature nicht mehr rechtzeitig in die fertige App übernommen werden konnte. \newline 

\noindent Es kann eine ScanActivity oder ein ScanFragment entwickelt werden, welches mithilfe künstlicher Intelligenz Produkte an ihrer Form erkennt. \newline 

\noindent Für Verkäufer könnte ein Webinterface implementiert werden, auf welchen eine Liste an Produkten im csv Format hochgeladen werden kann. Eine weitere Fuktion des Webinterfaces wäre das Hochladen von 3D Modelle für die einzelnen Produkte. \newline

\noindent Eine wichtige Erweiterung für die App könnte das Erstellen von einzelnen Einkaufslisten sein, in die mehrere Produkte gespeichert werden können. \newline 

\noindent Eine weitere Funktion wäre, dass der Nutzer sein erstelltes Konto wieder löschen kann. Hierbei wird der Nutzer zu erst gefragt ob er denn wirklich seinen Account auch wirklich löschen möchte. Dies ist soweit in der App implementiert, jedoch gibt es aktuell keine Backend Funktion, welche dies auch tatsächlich umsetzt. \newline 

\noindent Ab einer gewissen Nutzerzahl macht es Sinn, dass ein Supportsystem eingeführt wird. \newline 

\subsection{Optimierung \& Verbesserung}

\noindent Die ProductDetailActivity ist sehr überladen mit Informationen und Buttons. Ein klares Design und eine Simplifizierung der Funktionen könnten die User Experience verbessern. \newline

\noindent Auf Seite des PHP Backends könnte der Bilderupload optimiert werden. Man könnte für ein Produktbild sowohl ein Bild in Originalgröße als auch ein Thumbnail generieren, welches dann für die ListView genutzt werden kann, damit Elemente schneller geladen werden können. \newline 

\noindent Beim Abfragen von allen Produkten (GET ../products/) könnte irgendwann der Fall eintreten, dass zu viele Produkte in der Datenbank vorhanden sind. In diesem Fall könnte Pagination Abhilfe schaffen, da nur eine gewisse Anzahl an Produkten angefragt werden. \newline  

\noindent Bei der Abfrage des Preises in der ProductDetailActivity, wird kurz danach ein 2ter Request gestellt, welcher den Shop abfrägt. Man könnte dies vermeiden, in dem man den Shop als Subressource in den Preis einbettet. \newline 

\noindent Bei einer noch größeren Menge an Daten, welche erzeugt werden, wenn die App rasch an Nutzer gewinnt, könnte man überlegen, ob die Datenbank auf mehrere Server aufgeteilt werden sollte (horizontale Skalierung). Dies kann entweder mit Partitioning oder mit Sharding umgesetzt werden. Mithilfe eines Load Balancers lässt sich die Last auf einzelne Server aufteilen. \newline 

\noindent Softwaretechnisch könnte man mit Einsatz von Map/Reduce ebenfalls eine weitere Optimierung erzielen.

\newpage


%\section{Wirtschaftlichkeitsbetrachtung}
% wurde ausgelassen
%\newpage

\section{Fazit und Reflexion}

\noindent Die Verwendung eines Frameworks (zum Beispiel Springboot) für die Erstellung der Rest Api, welche die benötigten Methoden bereits mitliefert, hätte einiges an Zeit und Arbeit einsparen können. \newline 

\noindent Beim Erstellen der App hätte man von Anfang an mit Test-Driven-Development arbeiten können, da man so eine größere Sicherheit reinbringen hätte können und man Fehler einfacher lokalisieren könnte, was erheblich Zeit einsparen könnte. \newline 

\noindent Letztendlich lebt die App von den Nutzern, was ein weiteres Problem darstellt: \newline Welcher Käufer nutzt die App, wenn kaum Content / Produkte vorhanden sind? Im Gegensatz dazu: Welcher Verkäufer möchte Produkte in der App anbieten, wenn keine solide Nutzerbasis vorhanden ist? Hier muss relativ früh ein Ausgleich geschaffen werden. 

\noindent Der Beta Test hat dies ebenfalls noch einmal bestätigt. Nutzer sind hier selbst verantwortlich um Produkte in die App einzustellen. \newline 

\noindent Insgesamt, hat sich dieses Projekt sehr gut geeignet um neue Erfahrungen zu sammeln im Bereich der Android Entwicklung und vor allem die Möglichkeiten mit neuen Technologien und Frameworks zu arbeiten, hat sich als sehr hilfreich herausgestellt. \newline

\noindent In diesem Fall steht die Entscheidung, lieber eine neue AR Technologie zu verwenden über der Entscheidung ältere Android Versionen weiterhin zu unterstützen. \newline

\newpage

\section{Quellenangabe}

\subsection{Verwendete Technologie, Frameworks und Software}

\noindent Android Studio (Primäre Entwicklungsumgebung)

\noindent Link: \textit{\url{https://developer.android.com/studio} \newline}

\noindent IntelliJ IDE  (Entwicklungsumgebung)

\noindent Link: \textit{\url{https://www.jetbrains.com/idea/} \newline}

\noindent Android SDK \newline
\noindent Android Emulator \newline

\noindent Android 9.0 (Testen) \newline 
\noindent Link: \textit{\url{https://www.android.com/versions/pie-9-0/} \newline}

\noindent Java 8 (Entwicklung und Veröffentlichung)

\noindent Link: \textit{\url{https://www.java.com/de/download/faq/java8.xml} \newline}

\noindent Java JDK 8 

\noindent Link: \textit{\url{https://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html} \newline}

\noindent Gradle 3.4.2 

\noindent Link: \textit{\url{https://gradle.org/} \newline}
\noindent Link: \textit{\url{https://docs.gradle.org/current/userguide/userguide.html} \newline}

\noindent Google Play Services 16 

\noindent Link: \textit{\url{https://developers.google.com/android/guides/overview} \newline}

\noindent Google AR Core

\noindent Link: \textit{\url{https://developers.google.com/ar/} \newline}
\noindent Link: \textit{\url{https://developers.google.com/ar/discover/} \newline}

\noindent Google AR Sceneform

\noindent Link: \textit{\url{https://developers.google.com/ar/develop/java/sceneform/} \newline}
\noindent Link: \textit{\url{https://developers.google.com/ar/develop/java/sceneform/samples} \newline}

\noindent Google AR Sceneform Tools Plugin für Android Studio / IntelliJ

\noindent Link: \textit{\url{https://plugins.jetbrains.com/plugin/10698-google-sceneform-tools-beta-} \newline}

\newpage

\noindent Google Developer Console 

\noindent Link: \textit{\url{https://console.developers.google.com/} \newline}

\noindent Google Play Console ( Veröffentlichung von Beta Versionen )

\noindent Link: \textit{\url{https://play.google.com/apps/publish/} \newline}

\noindent ZXing Barcode Scanner

\noindent Link: \textit{\url{https://github.com/zxing/zxing} \newline}

\noindent Retrofit2 (Anbindung zur Rest Api)

\noindent Link: \textit{\url{https://square.github.io/retrofit/} \newline}
\noindent Link: \textit{\url{https://github.com/square/retrofit} \newline}

\noindent Gson ((De-)Serialisierung von Java Objekten in JSON)

\noindent Link: \textit{\url{https://github.com/google/gson} \newline}

\noindent Picasso (Bibliothek zum Herunterladen von Bilder)

\noindent Link: \textit{\url{https://square.github.io/picasso/} \newline}
\noindent Link: \textit{\url{https://github.com/square/picasso} \newline}

\noindent Glide (Bibliothek zum Herunterladen von Bilder)

\noindent Link: \textit{\url{https://bumptech.github.io/glide/} \newline}
\noindent Link: \textit{\url{https://github.com/bumptech/glide} \newline}

\noindent SQLite (Datenbankverwaltungssystem)

\noindent Link: \textit{\url{https://www.sqlite.org/index.html} \newline}
\noindent Link: \textit{\url{https://www.sqlite.org/docs.html} \newline}

\noindent Linux Ubuntu (Remote Server) 

\noindent Link: \textit{\url{https://ubuntu.com/} \newline}

\noindent Plesk (Oberfläche Server)

\noindent Link: \textit{\url{https://www.plesk.com/} \newline}

\noindent Apache (Webserver)

\noindent Link: \textit{\url{http://www.apache.org/} \newline} 
\noindent Link: \textit{\url{https://httpd.apache.org/} \newline}
\noindent Link: \textit{\url{https://httpd.apache.org/docs/} \newline}

\noindent PHP (Rest Api und Backend) 

\noindent Link: \textit{\url{https://www.php.net/manual/de/intro-whatis.php} \newline}

\newpage

\noindent phpMyAdmin (Webinterface Datenbank)

\noindent Link: \textit{\url{https://www.phpmyadmin.net/} \newline}

\noindent MySQL (Datenbankverwaltungssystem) 

\noindent Link: \textit{\url{https://www.mysql.com/de/} \newline}

\noindent Git (Versionsverwaltung)

\noindent Link: \textit{\url{https://git-scm.com/doc} \newline}

\noindent Bitbucket (Repository)

\noindent Link: \textit{\url{https://www.atlassian.com/de/software/bitbucket} \newline}
\noindent Link: \textit{\url{https://bitbucket.student.fiw.fhws.de:8443/dashboard} \newline}

\noindent Github (Repository)

\noindent Link: \textit{\url{https://github.com/} \newline}
\noindent Link: \textit{\url{https://github.com/maxr2011/} \newline}

\noindent Trello (Aufgabenverwaltung) 

\noindent Link: \textit{\url{https://trello.com/de} \newline}

\noindent OneDrive (Cloud-Speicherung)

\noindent Link: \textit{\url{https://onedrive.live.com/about/de-de/} \newline}

\noindent Draw.io (Skizzenanfertigung)

\noindent Link: \textit{\url{https://www.draw.io/} \newline}

\noindent Putty (SSH Verbindung zum Remote Server)

\noindent Link: \textit{\url{https://www.putty.org/} \newline}

\noindent WinSCP (DateiBrowser um auf Server Dateien hochzuladen / zu verändern)

\noindent Link: \textit{\url{https://winscp.net/eng/index.php} \newline}

\noindent HeidiSQL (SQL Client um Abfragen auf dem Server durchzuführen) 

\noindent Link: \textit{\url{https://www.heidisql.com/} \newline}

\noindent Postman (Testen der Rest Schnittstelle)

\noindent Link: \textit{\url{https://www.getpostman.com/} \newline}

\noindent Google Poly (Beziehen der 3D Modelle) 

\noindent Link: \textit{\url{https://poly.google.com/} \newline}



\newpage

\subsection{Verlinkung Repositories}

Die folgenden Repositories sind private Repositories auf Bitbucket oder GitHub. \newline

\noindent \textbf{App: ProductAR}

\noindent Bitbucket: \textit{\url{https://bitbucket.student.fiw.fhws.de:8443/users/k40216/repos/productar/} \newline}
\noindent GitHub: \textit{\url{https://github.com/maxr2011/productar} \newline }

\noindent \textbf{PHP Backend / Rest Api}

\noindent Bitbucket: \textit{\url{https://bitbucket.student.fiw.fhws.de:8443/users/k40216/repos/productar_php_backend/} \newline}
\noindent GitHub: \textit{\url{https://github.com/maxr2011/product_ar_backend} \newline}

\noindent \textbf{Dokumentation in LaTeX Quellcode und JavaDoc}

\noindent GitHub: \textit{\url{https://github.com/maxr2011/productar_ducumentation} \newline}

\noindent \textbf{SQL Backup}

\noindent Bitbucket: \textit{\url{https://bitbucket.student.fiw.fhws.de:8443/users/k40216/repos/productar_sql_backup/} \newline}
\noindent GitHub: \textit{\url{https://github.com/maxr2011/productar_sql_backup} \newline}

\newpage

\subsection{Verlinkung Tutorials}

\noindent \textbf{Google AR Core Tutorial (inklusive Playlist)}

\noindent \textit{\url{https://www.youtube.com/watch?v=EWXGaypl2ms\&list=PLsOU6EOcj51cEDYpCLK\_bzo4qtjOwDWfW\&index=2} \newline}

\noindent \textbf{QR und Barcode Scanner Tutorial}

\noindent \textit{\url{https://www.youtube.com/watch?v=otkz5Cwdw38} \newline}

\noindent \textbf{SQLite Database Tutorial}

\noindent \textit{\url{https://www.youtube.com/watch?v=KUq5wf3Mh0c} \newline}

\noindent \textbf{Coding in Flow Tutorials}

\noindent \textit{\url{https://www.youtube.com/channel/UC_Fh8kvtkVPkeihBs42jGcA/playlists} \newline}

\noindent \textbf{TextInputLayout Tutorial}

\noindent \textit{\url{https://www.youtube.com/watch?v=veOZTvAdzJ8} \newline}

\noindent \textbf{Retrofit Tutorial (inklusive Playlist)}

\noindent \textit{\url{https://www.youtube.com/watch?v=4JGvDUlfk7Y\&list=PLrnPJCHvNZuCbuD3xpfKzQWOj3AXybSaM} \newline}

\noindent \textbf{CodingWithMitch Tutorials}

\noindent \textit{\url{https://www.youtube.com/channel/UCoNZZLhPuuRteu02rh7bzsw/playlists} \newline}

\noindent \textbf{SQLite Database Tutorial}

\noindent \textit{\url{https://www.youtube.com/watch?v=aQAIMY-HzL8} \newline}

\noindent \textbf{ListView Tutorial}

\noindent \textit{\url{https://www.youtube.com/watch?v=cKUxiqNB5y0} \newline}

\newpage


\end{document}
